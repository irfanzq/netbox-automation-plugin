{% extends 'base/layout.html' %}
{% load i18n %}
{% load form_helpers %}

{% block title %}{% trans "VLAN Deployment" %}{% endblock %}

{% block content %}
<style>
  /* MINIMAL FIX: Only device names in accordion buttons in dark mode - nothing else */
  
  /* Device names in accordion buttons - Vibrant colors that work in both light and dark modes */
  .accordion-button .device-name,
  .accordion-button strong.device-name {
    font-weight: 600 !important;
  }
  
  /* Ensure vibrant colors are visible in dark mode with slight adjustment */
  html[data-theme="dark"] .accordion-button .device-name,
  body.dark-mode .accordion-button .device-name,
  body[data-bs-theme="dark"] .accordion-button .device-name {
    opacity: 1 !important;
    filter: brightness(1.2) !important; /* Slightly brighter in dark mode for better visibility */
  }
  
  /* Ensure vibrant colors are visible in light mode */
  html[data-theme="light"] .accordion-button .device-name,
  body:not(.dark-mode) .accordion-button .device-name {
    opacity: 1 !important;
  }
  
  /* Force dark text in ALL input fields for light mode */
  .form-control,
  .form-select,
  select.form-control,
  select.form-select,
  textarea.form-control,
  input[type="text"],
  input[type="number"],
  input[type="email"],
  input[type="password"],
  input[type="search"],
  input.form-control,
  textarea {
    background-color: #ffffff !important; /* White background in light mode */
    color: #212529 !important; /* Pure black text for light mode */
    border-color: var(--nbx-color-border-input, #ced4da) !important;
  }
  
  /* Force white background and black text in dark mode - highest specificity */
  html[data-theme="dark"] .form-control,
  html[data-theme="dark"] .form-select,
  html[data-theme="dark"] select.form-control,
  html[data-theme="dark"] select.form-select,
  html[data-theme="dark"] textarea.form-control,
  html[data-theme="dark"] input[type="text"],
  html[data-theme="dark"] input[type="number"],
  html[data-theme="dark"] input[type="email"],
  html[data-theme="dark"] input[type="password"],
  html[data-theme="dark"] input[type="search"],
  html[data-theme="dark"] input.form-control,
  html[data-theme="dark"] textarea,
  html[data-theme="dark"] .card-body .form-control,
  html[data-theme="dark"] .card-body input[type="text"],
  html[data-theme="dark"] .card-body input[type="number"],
  html[data-theme="dark"] .card-body textarea,
  body.dark-mode .form-control,
  body.dark-mode .form-select,
  body.dark-mode select.form-control,
  body.dark-mode select.form-select,
  body.dark-mode textarea.form-control,
  body.dark-mode input[type="text"],
  body.dark-mode input[type="number"],
  body.dark-mode input[type="email"],
  body.dark-mode input[type="password"],
  body.dark-mode input[type="search"],
  body.dark-mode input.form-control,
  body.dark-mode textarea,
  body.dark-mode .card-body .form-control,
  body.dark-mode .card-body input[type="text"],
  body.dark-mode .card-body input[type="number"],
  body.dark-mode .card-body textarea {
    background-color: #ffffff !important; /* White background in dark mode */
    color: #212529 !important; /* Black text in dark mode - force for readability */
  }
  
  .form-control::placeholder {
    color: #212529 !important; /* Black for light mode */
    opacity: 0.7;
  }
  
  html[data-theme="dark"] .form-control::placeholder,
  body.dark-mode .form-control::placeholder {
    color: #ffffff !important; /* White for dark mode */
    opacity: 0.7;
  }
  
  .form-control:focus,
  .form-select:focus,
  select.form-control:focus,
  select.form-select:focus,
  textarea.form-control:focus {
    background-color: var(--nbx-color-bg-input, #fff) !important;
    color: #212529 !important; /* Black for light mode */
    border-color: var(--nbx-color-border-input-focus, #86b7fe) !important;
  }
  
  html[data-theme="dark"] .form-control:focus,
  html[data-theme="dark"] .form-select:focus,
  html[data-theme="dark"] select.form-control:focus,
  html[data-theme="dark"] select.form-select:focus,
  html[data-theme="dark"] textarea.form-control:focus,
  html[data-theme="dark"] input[type="text"]:focus,
  html[data-theme="dark"] input[type="number"]:focus,
  html[data-theme="dark"] input.form-control:focus,
  html[data-theme="dark"] textarea:focus,
  body.dark-mode .form-control:focus,
  body.dark-mode .form-select:focus,
  body.dark-mode select.form-control:focus,
  body.dark-mode select.form-select:focus,
  body.dark-mode textarea.form-control:focus,
  body.dark-mode input[type="text"]:focus,
  body.dark-mode input[type="number"]:focus,
  body.dark-mode input.form-control:focus,
  body.dark-mode textarea:focus {
    background-color: #ffffff !important; /* White background in dark mode */
    color: #212529 !important; /* Black text in dark mode - force for readability */
  }
  
  /* Checkbox and radio button styling for dark mode */
  .form-check-input {
    background-color: var(--nbx-color-bg-input, #fff) !important;
    border-color: var(--nbx-color-border-input, #ced4da) !important;
  }
  
  html[data-theme="dark"] .form-check-input,
  body.dark-mode .form-check-input {
    background-color: #ffffff !important; /* White background in dark mode */
    border-color: var(--nbx-color-border-input, #ced4da) !important;
  }
  
  /* Light mode: checked state */
  .form-check-input:checked {
    background-color: var(--nbx-color-primary, #0d6efd) !important;
    border-color: var(--nbx-color-primary, #0d6efd) !important;
  }
  
  /* Light mode: radio button checked - black dot */
  .form-check-input[type="radio"]:checked {
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='2' fill='%23212529'/%3e%3c/svg%3e") !important;
  }
  
  /* Light mode: checkbox checked - white checkmark */
  .form-check-input[type="checkbox"]:checked {
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%23ffffff' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M6 10l3 3l6-6'/%3e%3c/svg%3e") !important;
  }
  
  /* Radio button checked state in dark mode - blue background with white dot */
  html[data-theme="dark"] .form-check-input[type="radio"]:checked,
  body.dark-mode .form-check-input[type="radio"]:checked {
    background-color: var(--nbx-color-primary, #0d6efd) !important;
    border-color: var(--nbx-color-primary, #0d6efd) !important;
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='2' fill='%23ffffff'/%3e%3c/svg%3e") !important; /* White dot for dark mode */
  }
  
  /* Checkbox checked state in dark mode - ensure visibility */
  html[data-theme="dark"] .form-check-input[type="checkbox"]:checked,
  body.dark-mode .form-check-input[type="checkbox"]:checked {
    background-color: var(--nbx-color-primary, #0d6efd) !important;
    border-color: var(--nbx-color-primary, #0d6efd) !important;
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%23ffffff' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M6 10l3 3l6-6'/%3e%3c/svg%3e") !important; /* White checkmark for dark mode */
  }
  
  /* Ensure radio buttons and checkboxes are visible when not checked in dark mode */
  html[data-theme="dark"] .form-check-input:not(:checked),
  body.dark-mode .form-check-input:not(:checked) {
    background-color: #ffffff !important;
    border-color: var(--nbx-color-border-input, #ced4da) !important;
  }
  
  .form-check-input:focus {
    border-color: var(--nbx-color-border-input-focus, #86b7fe) !important;
    box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
  }
  
  /* Datalist dropdown styling */
  datalist option {
    background-color: var(--nbx-color-bg-input, #fff) !important;
    color: #212529 !important; /* Black for light mode */
  }
  
  html[data-theme="dark"] datalist option,
  body.dark-mode datalist option {
    background-color: var(--nbx-color-bg-input, #2a2a2a) !important;
    color: #ffffff !important;
  }
  
  /* Select dropdown options */
  select option {
    background-color: var(--nbx-color-bg-input, #fff) !important;
    color: #212529 !important; /* Black for light mode */
  }
  
  html[data-theme="dark"] select option,
  body.dark-mode select option {
    background-color: var(--nbx-color-bg-input, #2a2a2a) !important;
    color: #ffffff !important;
  }
  
  #interfaces-checkbox-container {
    background-color: var(--nbx-color-bg-secondary, #f8f9fa) !important;
    border-color: var(--nbx-color-border-default, #dee2e6) !important;
    color: #212529 !important; /* Black for light mode */
  }
  
  html[data-theme="dark"] #interfaces-checkbox-container,
  body.dark-mode #interfaces-checkbox-container {
    background-color: var(--nbx-color-bg-secondary, #2a2a2a) !important;
    color: #ffffff !important;
  }
  
  /* Ensure all text inside the interfaces container is visible */
  #interfaces-checkbox-container,
  #interfaces-checkbox-container * {
    color: #212529 !important; /* Black for light mode */
  }
  
  html[data-theme="dark"] #interfaces-checkbox-container,
  html[data-theme="dark"] #interfaces-checkbox-container *,
  body.dark-mode #interfaces-checkbox-container,
  body.dark-mode #interfaces-checkbox-container * {
    color: #ffffff !important; /* White for dark mode */
  }
  
  /* Exception for muted text inside container - NO GREY, fully visible */
  #interfaces-checkbox-container .text-muted,
  #interfaces-checkbox-container p.text-muted {
    color: #212529 !important; /* Black for light mode */
    opacity: 1 !important;
  }
  
  html[data-theme="dark"] #interfaces-checkbox-container .text-muted,
  html[data-theme="dark"] #interfaces-checkbox-container p.text-muted,
  body.dark-mode #interfaces-checkbox-container .text-muted,
  body.dark-mode #interfaces-checkbox-container p.text-muted {
    color: #ffffff !important; /* White for dark mode */
  }
  
  /* Label for "Available Interfaces" section - NO GREY, fully visible */
  label.form-label.text-muted.small {
    color: #212529 !important; /* Black for light mode */
    opacity: 1 !important;
  }
  
  html[data-theme="dark"] label.form-label.text-muted.small,
  body.dark-mode label.form-label.text-muted.small {
    color: #ffffff !important; /* White for dark mode */
  }
  
  .form-check-label {
    color: var(--nbx-color-fg-default, #212529) !important;
  }
  
  /* Ensure form-check elements inside container are visible */
  #interfaces-checkbox-container .form-check {
    color: var(--nbx-color-fg-default, #212529) !important;
  }
  
  #interfaces-checkbox-container .form-check-label {
    color: var(--nbx-color-fg-default, #212529) !important;
  }
  
  #interfaces-checkbox-container .form-check-input {
    background-color: var(--nbx-color-bg-input, #fff) !important;
    border-color: var(--nbx-color-border-input, #ced4da) !important;
  }
  
  #interfaces-checkbox-container .form-check-input:checked {
    background-color: var(--nbx-color-primary, #0d6efd) !important;
    border-color: var(--nbx-color-primary, #0d6efd) !important;
  }
  
  .invalid-feedback {
    color: var(--nbx-color-danger, #dc3545) !important;
  }
  
  /* Light mode: Light pink background with dark red text */
  .alert-danger {
    background-color: #f8d7da !important; /* Light pink background */
    color: #721c24 !important; /* Dark red text */
    border-color: #f5c2c7 !important;
  }
  
  /* Dark mode: Dark red background with white text */
  html[data-theme="dark"] .alert-danger,
  body.dark-mode .alert-danger {
    background-color: #5a1a1a !important; /* Dark red background */
    color: #ffffff !important; /* White text */
    border-color: #8b2635 !important;
  }
  
  /* Select2 styling for dark mode */
  .select2-container--default .select2-selection--multiple,
  .select2-container--default .select2-selection--single {
    background-color: var(--nbx-color-bg-input, #fff) !important;
    color: #212529 !important; /* Black for light mode */
    border-color: var(--nbx-color-border-input, #ced4da) !important;
  }
  
  html[data-theme="dark"] .select2-container--default .select2-selection--multiple,
  html[data-theme="dark"] .select2-container--default .select2-selection--single,
  body.dark-mode .select2-container--default .select2-selection--multiple,
  body.dark-mode .select2-container--default .select2-selection--single {
    background-color: var(--nbx-color-bg-input, #2a2a2a) !important;
    color: #ffffff !important; /* White for dark mode */
    border-color: var(--nbx-color-border-input, #495057) !important;
  }
  
  .select2-container--default .select2-selection--multiple .select2-selection__rendered {
    color: #212529 !important; /* Black for light mode */
  }
  
  html[data-theme="dark"] .select2-container--default .select2-selection--multiple .select2-selection__rendered,
  body.dark-mode .select2-container--default .select2-selection--multiple .select2-selection__rendered {
    color: #ffffff !important; /* White for dark mode */
  }
  
  .select2-container--default .select2-selection__choice {
    background-color: var(--nbx-color-bg-secondary, #e9ecef) !important;
    color: #212529 !important; /* Black for light mode */
    border-color: var(--nbx-color-border-default, #ced4da) !important;
  }
  
  html[data-theme="dark"] .select2-container--default .select2-selection__choice,
  body.dark-mode .select2-container--default .select2-selection__choice {
    background-color: var(--nbx-color-bg-secondary, #495057) !important;
    color: #ffffff !important; /* White for dark mode */
    border-color: var(--nbx-color-border-default, #6c757d) !important;
  }
  
  .select2-container--default .select2-selection__choice__remove {
    color: #212529 !important; /* Black for light mode */
  }
  
  html[data-theme="dark"] .select2-container--default .select2-selection__choice__remove,
  body.dark-mode .select2-container--default .select2-selection__choice__remove {
    color: #ffffff !important; /* White for dark mode */
  }
  
  .select2-dropdown {
    background-color: var(--nbx-color-bg-input, #fff) !important;
    border-color: var(--nbx-color-border-input, #ced4da) !important;
  }
  
  html[data-theme="dark"] .select2-dropdown,
  body.dark-mode .select2-dropdown {
    background-color: var(--nbx-color-bg-input, #2a2a2a) !important;
    border-color: var(--nbx-color-border-input, #495057) !important;
  }
  
  .select2-results__option {
    background-color: var(--nbx-color-bg-input, #fff) !important;
    color: #212529 !important; /* Black for light mode */
  }
  
  html[data-theme="dark"] .select2-results__option,
  body.dark-mode .select2-results__option {
    background-color: var(--nbx-color-bg-input, #2a2a2a) !important;
    color: #ffffff !important; /* White for dark mode */
  }
  
  .select2-results__option--highlighted {
    background-color: var(--nbx-color-primary, #0d6efd) !important;
    color: #ffffff !important;
  }
  
  .select2-search__field {
    background-color: var(--nbx-color-bg-input, #fff) !important;
    color: #212529 !important; /* Black for light mode */
  }
  
  html[data-theme="dark"] .select2-search__field,
  body.dark-mode .select2-search__field {
    background-color: var(--nbx-color-bg-input, #2a2a2a) !important;
    color: #ffffff !important; /* White text for dark mode - user needs to see what they type */
  }
  
  .select2-search__field::placeholder {
    color: #212529 !important; /* Black for light mode */
    opacity: 0.7;
  }
  
  html[data-theme="dark"] .select2-search__field::placeholder,
  body.dark-mode .select2-search__field::placeholder {
    color: #ffffff !important; /* White for dark mode */
    opacity: 0.7;
  }
  
  /* Alert boxes styling for sync mode info messages */
  .alert {
    color: var(--nbx-color-fg-default) !important;
  }
  
  .alert-info {
    background-color: var(--nbx-color-bg-info) !important;
    border-color: var(--nbx-color-border-info) !important;
    color: var(--nbx-color-fg-default) !important;
  }
  
  /* Ensure all child elements in alert-info inherit proper colors */
  .alert-info *,
  .alert-info p,
  .alert-info ul,
  .alert-info li,
  .alert-info strong {
    color: inherit !important;
  }
  
  .alert-success {
    background-color: var(--nbx-color-bg-success) !important;
    border-color: var(--nbx-color-border-success) !important;
    color: var(--nbx-color-fg-default) !important;
  }
  
  /* Ensure all child elements in alert-success inherit proper colors */
  .alert-success *,
  .alert-success p,
  .alert-success ul,
  .alert-success li,
  .alert-success strong {
    color: inherit !important;
  }
  
  .alert-warning {
    background-color: var(--nbx-color-bg-warning) !important;
    border-color: var(--nbx-color-border-warning) !important;
    color: var(--nbx-color-fg-default) !important;
  }
  
  /* Ensure all child elements in alert-warning inherit proper colors */
  .alert-warning *,
  .alert-warning p,
  .alert-warning ul,
  .alert-warning li,
  .alert-warning strong {
    color: inherit !important;
  }
  
  /* Badges - use NetBox CSS variables dynamically */
  .badge {
    font-size: 0.75rem !important;
    padding: 0.25em 0.6em !important;
    border-radius: 0.25rem !important;
  }
  
  .badge.bg-danger {
    background-color: var(--nbx-color-danger, #dc3545) !important;
    color: #ffffff !important;
  }
  
  html[data-theme="dark"] .badge.bg-danger,
  body.dark-mode .badge.bg-danger {
    background-color: var(--nbx-color-danger, #dc3545) !important;
    color: #ffffff !important;
  }
  
  .badge.bg-warning {
    background-color: var(--nbx-color-warning, #ffc107) !important;
    color: #000000 !important;
  }
  
  html[data-theme="dark"] .badge.bg-warning,
  body.dark-mode .badge.bg-warning {
    background-color: var(--nbx-color-warning, #ffc107) !important;
    color: #000000 !important;
  }
  
  .badge.bg-info {
    background-color: var(--nbx-color-info, #0dcaf0) !important;
    color: #000000 !important;
  }
  
  html[data-theme="dark"] .badge.bg-info,
  body.dark-mode .badge.bg-info {
    background-color: var(--nbx-color-info, #0dcaf0) !important;
    color: #000000 !important;
  }
  
  .badge.bg-success {
    background-color: var(--nbx-color-success, #198754) !important;
    color: #ffffff !important;
  }
  
  html[data-theme="dark"] .badge.bg-success,
  body.dark-mode .badge.bg-success {
    background-color: var(--nbx-color-success, #198754) !important;
    color: #ffffff !important;
  }
  
  .badge.bg-secondary {
    background-color: var(--nbx-color-bg-secondary, #6c757d) !important;
    color: var(--nbx-color-fg-default, #ffffff) !important;
  }
  
  html[data-theme="dark"] .badge.bg-secondary,
  body.dark-mode .badge.bg-secondary {
    background-color: var(--nbx-color-bg-secondary, #6c757d) !important;
    color: var(--nbx-color-fg-default, #ffffff) !important;
  }
  
  .alert code {
    background-color: rgba(0, 0, 0, 0.1) !important;
    color: inherit !important;
  }
  
  html[data-theme="dark"] .alert code,
  body.dark-mode .alert code {
    background-color: rgba(255, 255, 255, 0.1) !important;
  }
  
  /* Loading overlay - dark mode compatible */
  #loading-overlay {
    background: rgba(0, 0, 0, 0.7) !important;
  }
  
  #loading-overlay > div {
    background: var(--nbx-color-bg-default, #fff) !important;
    color: #212529 !important; /* Black for light mode */
  }
  
  html[data-theme="dark"] #loading-overlay > div,
  body.dark-mode #loading-overlay > div {
    background: var(--nbx-color-bg-default, #2a2a2a) !important;
    color: #ffffff !important;
  }
  
  #loading-overlay h4 {
    color: #212529 !important; /* Black for light mode */
  }
  
  html[data-theme="dark"] #loading-overlay h4,
  body.dark-mode #loading-overlay h4 {
    color: #ffffff !important; /* White for dark mode */
  }
  
  #loading-overlay .text-muted,
  #loading-overlay p {
    color: #212529 !important; /* Black for light mode */
  }
  
  html[data-theme="dark"] #loading-overlay .text-muted,
  html[data-theme="dark"] #loading-overlay p,
  body.dark-mode #loading-overlay .text-muted,
  body.dark-mode #loading-overlay p {
    color: #ffffff !important; /* White for dark mode */
  }
  
  /* Disabled button styling - NO GREY text */
  #deploy-btn:disabled {
    background-color: var(--nbx-color-bg-tertiary, #6c757d) !important;
    border-color: var(--nbx-color-bg-tertiary, #6c757d) !important;
    color: #212529 !important; /* Black for light mode */
    opacity: 0.6;
    cursor: not-allowed !important;
  }
  
  html[data-theme="dark"] #deploy-btn:disabled,
  body.dark-mode #deploy-btn:disabled {
    color: #ffffff !important; /* White for dark mode */
  }
  
  /* Accordion buttons - ensure device names are visible in dark mode */
  #interfaces-checkbox-container .accordion-button,
  .accordion-button {
    color: var(--nbx-color-fg-default) !important;
    background-color: var(--nbx-color-bg-default) !important;
  }
  
  #interfaces-checkbox-container .accordion-button strong,
  #interfaces-checkbox-container .accordion-button *,
  .accordion-button strong,
  .accordion-button * {
    color: var(--nbx-color-fg-default) !important;
  }
  
  #interfaces-checkbox-container .accordion-button:not(.collapsed),
  .accordion-button:not(.collapsed) {
    color: var(--nbx-color-fg-default) !important;
    background-color: var(--nbx-color-bg-default) !important;
  }
  
  #interfaces-checkbox-container .accordion-button:not(.collapsed) strong,
  #interfaces-checkbox-container .accordion-button:not(.collapsed) *,
  .accordion-button:not(.collapsed) strong,
  .accordion-button:not(.collapsed) * {
    color: var(--nbx-color-fg-default) !important;
  }
  
  /* Explicit dark mode overrides for accordion buttons - MAXIMUM SPECIFICITY */
  html[data-theme="dark"] #interfaces-checkbox-container .accordion .accordion-item .accordion-header .accordion-button,
  html[data-theme="dark"] #interfaces-checkbox-container .accordion-button,
  html[data-theme="dark"] #interfaces-checkbox-container .accordion-button button,
  html[data-theme="dark"] .accordion .accordion-item .accordion-header .accordion-button,
  html[data-theme="dark"] .accordion-button,
  html[data-theme="dark"] .accordion-button button,
  html[data-theme="dark"] .accordion-header button,
  html[data-theme="dark"] .accordion-header button.accordion-button,
  body.dark-mode #interfaces-checkbox-container .accordion .accordion-item .accordion-header .accordion-button,
  body.dark-mode #interfaces-checkbox-container .accordion-button,
  body.dark-mode #interfaces-checkbox-container .accordion-button button,
  body.dark-mode .accordion .accordion-item .accordion-header .accordion-button,
  body.dark-mode .accordion-button,
  body.dark-mode .accordion-button button,
  body.dark-mode .accordion-header button,
  body.dark-mode .accordion-header button.accordion-button {
    color: #ffffff !important;
    background-color: var(--nbx-color-bg-default) !important;
  }
  
  html[data-theme="dark"] #interfaces-checkbox-container .accordion .accordion-item .accordion-header .accordion-button strong,
  html[data-theme="dark"] #interfaces-checkbox-container .accordion-button strong,
  html[data-theme="dark"] #interfaces-checkbox-container .accordion-button button strong,
  html[data-theme="dark"] #interfaces-checkbox-container .accordion-button *,
  html[data-theme="dark"] .accordion .accordion-item .accordion-header .accordion-button strong,
  html[data-theme="dark"] .accordion-button strong,
  html[data-theme="dark"] .accordion-button button strong,
  html[data-theme="dark"] .accordion-button *,
  html[data-theme="dark"] .accordion-header button strong,
  html[data-theme="dark"] .accordion-header button.accordion-button strong,
  html[data-theme="dark"] .accordion-header button *,
  html[data-theme="dark"] .accordion-header button.accordion-button *,
  body.dark-mode #interfaces-checkbox-container .accordion .accordion-item .accordion-header .accordion-button strong,
  body.dark-mode #interfaces-checkbox-container .accordion-button strong,
  body.dark-mode #interfaces-checkbox-container .accordion-button button strong,
  body.dark-mode #interfaces-checkbox-container .accordion-button *,
  body.dark-mode .accordion .accordion-item .accordion-header .accordion-button strong,
  body.dark-mode .accordion-button strong,
  body.dark-mode .accordion-button button strong,
  body.dark-mode .accordion-button *,
  body.dark-mode .accordion-header button strong,
  body.dark-mode .accordion-header button.accordion-button strong,
  body.dark-mode .accordion-header button *,
  body.dark-mode .accordion-header button.accordion-button * {
    color: #ffffff !important;
  }
  
  html[data-theme="dark"] #interfaces-checkbox-container .accordion .accordion-item .accordion-header .accordion-button:not(.collapsed),
  html[data-theme="dark"] #interfaces-checkbox-container .accordion .accordion-item .accordion-header .accordion-button:not(.collapsed) strong,
  html[data-theme="dark"] #interfaces-checkbox-container .accordion-button:not(.collapsed),
  html[data-theme="dark"] #interfaces-checkbox-container .accordion-button:not(.collapsed) strong,
  html[data-theme="dark"] .accordion .accordion-item .accordion-header .accordion-button:not(.collapsed),
  html[data-theme="dark"] .accordion .accordion-item .accordion-header .accordion-button:not(.collapsed) strong,
  html[data-theme="dark"] .accordion-button:not(.collapsed),
  html[data-theme="dark"] .accordion-button:not(.collapsed) strong,
  body.dark-mode #interfaces-checkbox-container .accordion .accordion-item .accordion-header .accordion-button:not(.collapsed),
  body.dark-mode #interfaces-checkbox-container .accordion .accordion-item .accordion-header .accordion-button:not(.collapsed) strong,
  body.dark-mode #interfaces-checkbox-container .accordion-button:not(.collapsed),
  body.dark-mode #interfaces-checkbox-container .accordion-button:not(.collapsed) strong,
  body.dark-mode .accordion .accordion-item .accordion-header .accordion-button:not(.collapsed),
  body.dark-mode .accordion .accordion-item .accordion-header .accordion-button:not(.collapsed) strong,
  body.dark-mode .accordion-button:not(.collapsed),
  body.dark-mode .accordion-button:not(.collapsed) strong {
    color: #ffffff !important;
    background-color: var(--nbx-color-bg-default) !important;
  }
  
  /* Also target text-white class if Bootstrap adds it */
  html[data-theme="dark"] .accordion-button.text-white,
  html[data-theme="dark"] .accordion-button.text-white strong,
  body.dark-mode .accordion-button.text-white,
  body.dark-mode .accordion-button.text-white strong {
    color: #ffffff !important;
  }
  
  /* Expand All / Collapse All buttons - dark mode compatible */
  .btn-outline-secondary {
    color: var(--nbx-color-fg-default) !important;
    border-color: var(--nbx-color-border-default) !important;
    background-color: transparent !important;
  }
  
  .btn-outline-secondary:hover {
    color: var(--nbx-color-fg-default) !important;
    background-color: var(--nbx-color-bg-secondary) !important;
    border-color: var(--nbx-color-border-default) !important;
  }
  
  /* Ensure interface labels and strong tags use proper colors */
  #interfaces-checkbox-container .form-check-label,
  #interfaces-checkbox-container .form-check-label strong,
  .accordion-body .form-check-label,
  .accordion-body .form-check-label strong,
  .form-check-label,
  .form-check-label strong {
    color: var(--nbx-color-fg-default) !important;
  }
  
  /* Ensure text-muted spans in interface labels are visible */
  #interfaces-checkbox-container .form-check-label .text-muted,
  .accordion-body .form-check-label .text-muted,
  .form-check-label .text-muted {
    color: var(--nbx-color-fg-muted, var(--nbx-color-fg-default)) !important;
    opacity: 1 !important;
  }
  
  /* Explicit dark mode overrides for interface labels */
  html[data-theme="dark"] #interfaces-checkbox-container .form-check-label,
  html[data-theme="dark"] #interfaces-checkbox-container .form-check-label strong,
  html[data-theme="dark"] .accordion-body .form-check-label,
  html[data-theme="dark"] .accordion-body .form-check-label strong,
  html[data-theme="dark"] .form-check-label,
  html[data-theme="dark"] .form-check-label strong,
  body.dark-mode #interfaces-checkbox-container .form-check-label,
  body.dark-mode #interfaces-checkbox-container .form-check-label strong,
  body.dark-mode .accordion-body .form-check-label,
  body.dark-mode .accordion-body .form-check-label strong,
  body.dark-mode .form-check-label,
  body.dark-mode .form-check-label strong {
    color: #ffffff !important;
  }
  
  /* Hide VLAN config container when sync mode is active */
  #vlan-config-container.hidden-by-sync {
    display: none !important;
    visibility: hidden !important;
    height: 0 !important;
    overflow: hidden !important;
    margin: 0 !important;
    padding: 0 !important;
  }
</style>
  <div class="row">
    <div class="col-md-12">
      <div class="card">
        <div class="card-header">
          <h5 class="card-title mb-0">{% trans "VLAN Deployment" %}</h5>
        </div>
        <div class="card-body">
          <p class="text-muted" style="color: var(--nbx-color-fg-default) !important;">
            {% trans "Deploy VLAN configurations to network devices and update NetBox interface assignments. Phase 1: Access mode (untagged) only." %}
          </p>

          {% if form.non_field_errors %}
            <div class="alert alert-danger" role="alert">
              {{ form.non_field_errors }}
            </div>
          {% endif %}

          <!-- Loading overlay -->
          <div id="loading-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 9999; align-items: center; justify-content: center;">
            <div style="background: var(--nbx-color-bg-default); padding: 30px; border-radius: 8px; text-align: center; max-width: 400px; color: var(--nbx-color-fg-default);">
              <div class="spinner-border text-primary mb-3" role="status" style="width: 3rem; height: 3rem;">
                <span class="visually-hidden">Loading...</span>
              </div>
              <h4>Deploying VLAN Configuration...</h4>
              <p class="mb-0">Applying configuration to devices. This may take a minute.</p>
            </div>
          </div>

          <form method="post" id="vlan-deployment-form">
            {% csrf_token %}

            {# Deployment Scope - Always visible #}
            <div class="mb-3">
              <label class="form-label">{{ form.deployment_scope.label }}</label>
              <div class="form-text" style="color: var(--nbx-color-fg-default) !important;">{{ form.deployment_scope.help_text }}</div>
              {% for radio in form.deployment_scope %}
                <div class="form-check">
                  {{ radio.tag }}
                  <label class="form-check-label" for="{{ radio.id_for_label }}">
                    {{ radio.choice_label }}
                  </label>
                </div>
              {% endfor %}
              {% if form.deployment_scope.errors %}
                <div class="invalid-feedback d-block">{{ form.deployment_scope.errors }}</div>
              {% endif %}
            </div>

            {# Sync NetBox to Device Checkbox #}
            <div class="mb-3">
              <div class="form-check">
                {{ form.sync_netbox_to_device }}
                <label for="{{ form.sync_netbox_to_device.id_for_label }}" class="form-check-label">
                  {{ form.sync_netbox_to_device.label }}
                </label>
                <div class="form-text" style="color: var(--nbx-color-fg-default) !important;">
                  {{ form.sync_netbox_to_device.help_text }}
                </div>
              </div>
              {% if form.sync_netbox_to_device.errors %}
                <div class="invalid-feedback d-block">{{ form.sync_netbox_to_device.errors }}</div>
              {% endif %}
              
              {# Deploy on Untagged Interfaces Checkbox (only shown in sync mode) #}
              <div id="deploy-untagged-container" class="form-check mt-3" style="display: none;">
                {{ form.deploy_untagged_interfaces }}
                <label for="{{ form.deploy_untagged_interfaces.id_for_label }}" class="form-check-label">
                  {{ form.deploy_untagged_interfaces.label }}
                </label>
                <div class="form-text" style="color: var(--nbx-color-fg-default) !important;">
                  {{ form.deploy_untagged_interfaces.help_text }}
                </div>
                {% if form.deploy_untagged_interfaces.errors %}
                  <div class="invalid-feedback d-block">{{ form.deploy_untagged_interfaces.errors }}</div>
                {% endif %}
              </div>
              
              <div id="sync-mode-info" class="alert alert-info" style="display: none; margin-top: 10px;">
                <strong>Sync Mode Active:</strong> Interfaces with VLAN configuration from NetBox will be synced to devices. 
                All interfaces are pre-selected - uncheck any you don't want to sync.
              </div>
            </div>

            {# Single Device Mode Fields #}
            <div id="single-device-fields" style="display: block;">
              <div class="mb-3">
                <label for="{{ form.devices.id_for_label }}" class="form-label required">{{ form.devices.label }}</label>
                {{ form.devices }}
                <div class="form-text" style="color: var(--nbx-color-fg-default) !important;">{{ form.devices.help_text }}</div>
                {% if form.devices.errors %}
                  <div class="invalid-feedback d-block">{{ form.devices.errors }}</div>
                {% endif %}
              </div>
            </div>

            {# Device Group Mode Fields #}
            <div id="group-device-fields" style="display: none;">
              <div class="mb-3">
                <label for="{{ form.site.id_for_label }}" class="form-label required">{{ form.site.label }}</label>
                {{ form.site }}
                <div class="form-text" style="color: var(--nbx-color-fg-default) !important;">{{ form.site.help_text }}</div>
                {% if form.site.errors %}
                  <div class="invalid-feedback d-block">{{ form.site.errors }}</div>
                {% endif %}
              </div>

              <div class="mb-3">
                <label for="{{ form.location.id_for_label }}" class="form-label required">{{ form.location.label }}</label>
                {{ form.location }}
                <div class="form-text" style="color: var(--nbx-color-fg-default) !important;">{{ form.location.help_text }}</div>
                {% if form.location.errors %}
                  <div class="invalid-feedback d-block">{{ form.location.errors }}</div>
                {% endif %}
              </div>

              <div class="mb-3">
                <label for="{{ form.manufacturer.id_for_label }}" class="form-label required">{{ form.manufacturer.label }}</label>
                {{ form.manufacturer }}
                <div class="form-text" style="color: var(--nbx-color-fg-default) !important;">{{ form.manufacturer.help_text }}</div>
                {% if form.manufacturer.errors %}
                  <div class="invalid-feedback d-block">{{ form.manufacturer.errors }}</div>
                {% endif %}
              </div>

              <div class="mb-3">
                <label for="{{ form.role.id_for_label }}" class="form-label required">{{ form.role.label }}</label>
                {{ form.role }}
                <div class="form-text" style="color: var(--nbx-color-fg-default) !important;">{{ form.role.help_text }}</div>
                {% if form.role.errors %}
                  <div class="invalid-feedback d-block">{{ form.role.errors }}</div>
                {% endif %}
              </div>

              {# Excluded Devices - Only available in Group mode #}
              <div class="mb-3">
                <label for="{{ form.excluded_devices.id_for_label }}" class="form-label">{{ form.excluded_devices.label }}</label>
                {{ form.excluded_devices }}
                <div class="form-text" style="color: var(--nbx-color-fg-default) !important;">{{ form.excluded_devices.help_text }}</div>
                {% if form.excluded_devices.errors %}
                  <div class="invalid-feedback d-block">{{ form.excluded_devices.errors }}</div>
                {% endif %}
              </div>
            </div>

            {# Interface Selection - Two fields: Checkboxes + Manual Entry #}
            <div class="mb-3">
              <label class="form-label required">Interfaces</label>

              {# Field 1: Checkbox list for available interfaces #}
              <div class="mb-2">
                <label class="form-label text-muted small" style="color: var(--nbx-color-fg-default) !important; opacity: 1 !important;">Available Interfaces (select from device)</label>
                <div id="interfaces-checkbox-container" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--nbx-color-border-default); padding: 10px; border-radius: 4px; background-color: var(--nbx-color-bg-secondary); color: var(--nbx-color-fg-default);">
                  <p class="text-muted mb-0" style="color: var(--nbx-color-fg-default) !important; opacity: 1 !important;">Select devices first to load interfaces</p>
                </div>
              </div>

              {# Field 2: Manual text input for custom interfaces #}
              <div class="mb-2" id="interfaces_manual_container">
                <label for="id_interfaces_manual" class="form-label text-muted small">Additional Interfaces (manual entry)</label>
                <textarea
                  id="id_interfaces_manual"
                  name="interfaces_manual"
                  class="form-control"
                  rows="2"
                  placeholder="Optional: Add custom interfaces (e.g., swp100, swp200 or swp1-48)"
                >{{ form.interfaces_manual.value|default:'' }}</textarea>
                <div class="form-text" style="color: var(--nbx-color-fg-default) !important;">
                  Enter additional interface names separated by commas or use ranges (e.g., swp1-48, Ethernet1-24).
                </div>
              </div>

              <div id="combined-selection-message" class="form-text" style="color: var(--nbx-color-fg-default) !important;">
                <strong>Combined selection:</strong> Both checkbox selections and manual entries will be combined and validated against NetBox.
              </div>

              {% if form.interfaces_select.errors %}
                <div class="invalid-feedback d-block">{{ form.interfaces_select.errors }}</div>
              {% endif %}
              {% if form.interfaces_manual.errors %}
                <div class="invalid-feedback d-block">{{ form.interfaces_manual.errors }}</div>
              {% endif %}
            </div>

            {# VLAN Configuration Fields - Only shown in normal mode (not sync mode) #}
            <div id="vlan-config-container" class="mb-3 vlan-config-fields">
              {# Untagged VLAN - Text input with autocomplete dropdown #}
              <div class="mb-3">
                <label for="id_untagged_vlan" class="form-label">{{ form.untagged_vlan.label }}</label>
                <div style="position: relative; max-width: 500px;">
                  <input
                    type="number"
                    id="id_untagged_vlan"
                    name="untagged_vlan"
                    class="form-control"
                    list="untagged_vlan_datalist"
                    placeholder="Type VLAN ID (e.g., 100) or click to see dropdown"
                    min="1"
                    max="4094"
                    value="{{ form.untagged_vlan.value|default:'' }}"
                    autocomplete="off"
                  />
                  <datalist id="untagged_vlan_datalist">
                    <!-- Will be populated dynamically with VLANs from device's location -->
                  </datalist>
                </div>
                <div class="form-text" style="color: var(--nbx-color-fg-default) !important;">{{ form.untagged_vlan.help_text }}</div>
                {% if form.untagged_vlan.errors %}
                  <div class="invalid-feedback d-block">{{ form.untagged_vlan.errors }}</div>
                {% endif %}
              </div>

              {# Tagged VLANs - Text input with autocomplete dropdown #}
              <div class="mb-3">
                <label for="id_tagged_vlans" class="form-label">{{ form.tagged_vlans.label }}</label>
                <div style="position: relative; max-width: 500px;">
                  <input
                    type="text"
                    id="id_tagged_vlans"
                    name="tagged_vlans"
                    class="form-control"
                    list="tagged_vlans_datalist"
                    placeholder="Type VLAN IDs separated by commas (e.g., 100,200,300) or click to see dropdown"
                    value="{{ form.tagged_vlans.value|default:'' }}"
                    autocomplete="off"
                  />
                  <datalist id="tagged_vlans_datalist">
                    <!-- Will be populated dynamically with VLANs from device's location -->
                  </datalist>
                </div>
                <div class="form-text" style="color: var(--nbx-color-fg-default) !important;">{{ form.tagged_vlans.help_text }}</div>
                {% if form.tagged_vlans.errors %}
                  <div class="invalid-feedback d-block">{{ form.tagged_vlans.errors }}</div>
                {% endif %}
              </div>
            </div>

            {# Deployment Options - Mutually exclusive #}
            <div class="mb-3">
              <label class="form-label">Deployment Mode</label>

              <div class="form-check">
                {{ form.dry_run }}
                <label class="form-check-label" for="{{ form.dry_run.id_for_label }}">
                  {{ form.dry_run.label }}
                </label>
                <div class="form-text" style="color: var(--nbx-color-fg-default) !important;">{{ form.dry_run.help_text }}</div>
              </div>

              <div class="form-check mt-2">
                {{ form.deploy_changes }}
                <label class="form-check-label" for="{{ form.deploy_changes.id_for_label }}">
                  {{ form.deploy_changes.label }}
                </label>
                <div class="form-text" style="color: var(--nbx-color-fg-default) !important;">{{ form.deploy_changes.help_text }}</div>
              </div>
            </div>

            <div class="mt-3">
              <button type="submit" class="btn btn-primary" id="deploy-btn" name="deploy" value="1">
                <i class="mdi mdi-upload-network"></i>
                <span id="deploy-btn-text">{% trans "Deploy VLAN" %}</span>
              </button>
            </div>
          </form>

          <script>
            // NetBox Theme Detection and Color Application
            function getNetBoxTheme() {
              try {
        return localStorage.getItem('netbox-color-mode') || 'light';
      } catch (e) {
        // Fallback: check if NetBox has set data-theme attribute
        const htmlEl = document.documentElement;
        if (htmlEl && htmlEl.getAttribute('data-theme') === 'dark') {
          return 'dark';
        }
        if (document.body && document.body.classList.contains('dark-mode')) {
          return 'dark';
        }
        return 'light';
      }
            }
            
            function isDarkMode() {
              return getNetBoxTheme() === 'dark';
            }
            
            function applyThemeColors() {
              const darkMode = isDarkMode();
              const textColor = darkMode ? '#ffffff' : '#212529';
              const bgColor = darkMode ? '#2a2a2a' : '#f8f9fa';
              
              // Force white background and black text for ALL input fields in dark mode
              if (darkMode) {
                document.querySelectorAll('.form-control, .form-select, input[type="text"], input[type="number"], input[type="email"], input[type="password"], input[type="search"], textarea, select').forEach(el => {
                  el.style.setProperty('background-color', '#ffffff', 'important');
                  el.style.setProperty('color', '#212529', 'important');
                });
              }
              
              // Apply to all text elements in card-body
              document.querySelectorAll('.card-body p, .card-body label, .card-body span, .card-body small, .card-body div, .card-body .form-text, .card-body .text-muted').forEach(el => {
                el.style.setProperty('color', textColor, 'important');
                if (el.classList.contains('text-muted') || el.classList.contains('form-text')) {
                  el.style.setProperty('opacity', '1', 'important');
                }
              });
              
              // Apply to card header
              document.querySelectorAll('.card-header, .card-header *').forEach(el => {
                el.style.setProperty('color', textColor, 'important');
              });
              
              // Apply to specific containers
              const containers = document.querySelectorAll('#interfaces-checkbox-container, .deployment-logs div, #loading-overlay > div');
              containers.forEach(container => {
                container.style.setProperty('background-color', darkMode ? '#2a2a2a' : bgColor, 'important');
                container.style.setProperty('color', textColor, 'important');
              });
              
              // Apply to form text elements
              document.querySelectorAll('.form-text, .text-muted, small').forEach(el => {
                el.style.setProperty('color', textColor, 'important');
                el.style.setProperty('opacity', '1', 'important');
              });
            }
            
            // Apply Select2 dark mode styles to dynamically created elements
            function applySelect2DarkMode() {
              const darkMode = isDarkMode();
              const textColor = darkMode ? '#ffffff' : '#212529';
              const bgColor = darkMode ? '#2a2a2a' : '#fff';
              const borderColor = darkMode ? '#495057' : '#ced4da';
              const choiceBg = darkMode ? '#495057' : '#e9ecef';
              
              // Apply to all Select2 elements
              document.querySelectorAll('.select2-container--default .select2-selection--multiple, .select2-container--default .select2-selection--single').forEach(el => {
                el.style.setProperty('background-color', bgColor, 'important');
                el.style.setProperty('color', textColor, 'important');
                el.style.setProperty('border-color', borderColor, 'important');
              });
              
              document.querySelectorAll('.select2-container--default .select2-selection__rendered').forEach(el => {
                el.style.setProperty('color', textColor, 'important');
              });
              
              document.querySelectorAll('.select2-container--default .select2-selection__choice').forEach(el => {
                el.style.setProperty('background-color', choiceBg, 'important');
                el.style.setProperty('color', textColor, 'important');
                el.style.setProperty('border-color', borderColor, 'important');
              });
              
              document.querySelectorAll('.select2-container--default .select2-selection__choice__remove').forEach(el => {
                el.style.setProperty('color', textColor, 'important');
              });
              
              document.querySelectorAll('.select2-dropdown').forEach(el => {
                el.style.setProperty('background-color', bgColor, 'important');
                el.style.setProperty('border-color', borderColor, 'important');
              });
              
              document.querySelectorAll('.select2-results__option').forEach(el => {
                el.style.setProperty('background-color', bgColor, 'important');
                el.style.setProperty('color', textColor, 'important');
              });
              
              document.querySelectorAll('.select2-search__field').forEach(el => {
                el.style.setProperty('background-color', bgColor, 'important');
                // Use appropriate text color based on mode (dark text in light mode, white in dark mode)
                el.style.setProperty('color', textColor, 'important');
              });
            }
            
            // Apply on page load
            document.addEventListener('DOMContentLoaded', function() {
              applyThemeColors();
              // Wait for Select2 to initialize, then apply styles
              setTimeout(applySelect2DarkMode, 500);
              
              // Listen for NetBox theme changes
              window.addEventListener('netbox.colorModeChanged', function(e) {
                setTimeout(function() {
                  applyThemeColors();
                  applySelect2DarkMode();
                }, 100);
              });
              
              // Also check periodically in case theme changes
              setInterval(function() {
                applyThemeColors();
                applySelect2DarkMode();
              }, 2000);
              
              // Use MutationObserver to watch for dynamically added Select2 elements
              const observer = new MutationObserver(function(mutations) {
                applySelect2DarkMode();
              });
              
              observer.observe(document.body, {
                childList: true,
                subtree: true
              });
            });
            
            // Make function available globally for dynamic elements
            window.getNetBoxTextColor = function() {
              return isDarkMode() ? '#ffffff' : '#212529';
            };
            
            // Show/hide fields based on deployment scope
            function updateFieldVisibility() {
              console.log('=== updateFieldVisibility called ===');
              
              const scopeRadio = document.querySelector('input[name="deployment_scope"]:checked');
              console.log('Scope radio found:', !!scopeRadio);
              
              // Safety check - return if no radio button is checked
              if (!scopeRadio) {
                console.warn('No deployment scope radio button is checked - using default "single"');
                // Default to single mode if no radio is checked
                const singleFields = document.getElementById('single-device-fields');
                const groupFields = document.getElementById('group-device-fields');
                console.log('Default mode - singleFields:', !!singleFields, 'groupFields:', !!groupFields);
                if (singleFields) {
                  singleFields.style.display = 'block';
                  singleFields.style.visibility = 'visible';
                  singleFields.setAttribute('style', 'display: block !important; visibility: visible !important;');
                  console.log('Set singleFields display to block');
                }
                if (groupFields) {
                  groupFields.style.display = 'none';
                  groupFields.style.visibility = 'hidden';
                  groupFields.setAttribute('style', 'display: none !important; visibility: hidden !important;');
                  console.log('Set groupFields display to none');
                }
                return;
              }
              
              const scope = scopeRadio.value;
              console.log('Deployment scope:', scope);
              
              const singleFields = document.getElementById('single-device-fields');
              const groupFields = document.getElementById('group-device-fields');
              console.log('Elements found - singleFields:', !!singleFields, 'groupFields:', !!groupFields);

              // Safety check - return if elements don't exist
              if (!singleFields || !groupFields) {
                console.error('Single or group device fields container not found!', {
                  singleFields: !!singleFields,
                  groupFields: !!groupFields,
                  singleFieldsId: singleFields ? singleFields.id : 'NOT FOUND',
                  groupFieldsId: groupFields ? groupFields.id : 'NOT FOUND'
                });
                return;
              }

              if (scope === 'single') {
                console.log('>>> Showing single device fields, hiding group fields');
                // Use multiple methods to ensure it works
                singleFields.style.display = 'block';
                singleFields.style.visibility = 'visible';
                singleFields.setAttribute('style', 'display: block !important; visibility: visible !important;');
                groupFields.style.display = 'none';
                groupFields.style.visibility = 'hidden';
                groupFields.setAttribute('style', 'display: none !important; visibility: hidden !important;');
                console.log('Applied styles - singleFields.display:', singleFields.style.display, 'groupFields.display:', groupFields.style.display);
              } else if (scope === 'group') {
                console.log('>>> Showing group device fields, hiding single fields');
                // Use multiple methods to ensure it works
                singleFields.style.display = 'none';
                singleFields.style.visibility = 'hidden';
                singleFields.setAttribute('style', 'display: none !important; visibility: hidden !important;');
                groupFields.style.display = 'block';
                groupFields.style.visibility = 'visible';
                groupFields.setAttribute('style', 'display: block !important; visibility: visible !important;');
                console.log('Applied styles - singleFields.display:', singleFields.style.display, 'groupFields.display:', groupFields.style.display);
              }
              
              // Update sync mode state after scope change (with error handling)
              try {
                updateSyncModeState();
              } catch (error) {
                console.error('Error in updateSyncModeState:', error);
              }
            }

            // Handle sync mode checkbox changes
            function updateSyncModeState() {
              console.log('=== updateSyncModeState called ===');
              
              const syncCheckbox = document.getElementById('id_sync_netbox_to_device');
              const vlanConfigContainer = document.getElementById('vlan-config-container');
              const untaggedVlanField = document.getElementById('id_untagged_vlan');
              const taggedVlansField = document.getElementById('id_tagged_vlans');
              const interfacesManualField = document.getElementById('id_interfaces_manual');
              const interfacesManualLabel = document.querySelector('label[for="id_interfaces_manual"]');
              const syncModeInfo = document.getElementById('sync-mode-info');
              const devicesSelect = document.getElementById('id_devices');
              const interfacesContainer = document.getElementById('interfaces-checkbox-container');
              const deployUntaggedContainer = document.getElementById('deploy-untagged-container');
              
              console.log('Elements found:', {
                syncCheckbox: !!syncCheckbox,
                vlanConfigContainer: !!vlanConfigContainer,
                untaggedVlanField: !!untaggedVlanField,
                taggedVlansField: !!taggedVlansField,
                interfacesManualField: !!interfacesManualField,
                interfacesManualContainer: !!document.getElementById('interfaces_manual_container'),
                syncModeInfo: !!syncModeInfo,
                deployUntaggedContainer: !!deployUntaggedContainer
              });
              
              if (!syncCheckbox) {
                console.warn('Sync checkbox not found in updateSyncModeState');
                return;
              }
              
              const isSyncMode = syncCheckbox.checked;
              console.log('>>> Sync mode checkbox checked:', isSyncMode);
              
              if (isSyncMode) {
                console.log('>>> APPLYING SYNC MODE - hiding VLAN fields');
                
                // Hide VLAN configuration container (untagged and tagged VLAN fields)
                if (vlanConfigContainer) {
                  console.log('Hiding VLAN config container');
                  vlanConfigContainer.style.display = 'none';
                  vlanConfigContainer.style.visibility = 'hidden';
                  vlanConfigContainer.style.height = '0';
                  vlanConfigContainer.style.overflow = 'hidden';
                  vlanConfigContainer.style.margin = '0';
                  vlanConfigContainer.style.padding = '0';
                  vlanConfigContainer.setAttribute('style', 'display: none !important; visibility: hidden !important; height: 0 !important; overflow: hidden !important; margin: 0 !important; padding: 0 !important;');
                  vlanConfigContainer.classList.add('hidden-by-sync');
                  console.log('VLAN container hidden and class added');
                } else {
                  console.warn('VLAN config container not found');
                }
                
                // Also hide individual fields as backup
                if (untaggedVlanField) {
                  untaggedVlanField.disabled = true;
                  const untaggedContainer = untaggedVlanField.closest('.mb-3');
                  if (untaggedContainer) {
                    untaggedContainer.setAttribute('style', 'display: none !important;');
                  }
                }
                if (taggedVlansField) {
                  taggedVlansField.disabled = true;
                  const taggedContainer = taggedVlansField.closest('.mb-3');
                  if (taggedContainer) {
                    taggedContainer.setAttribute('style', 'display: none !important;');
                  }
                }
                
                // Hide additional interfaces field and its container
                const interfacesManualContainer = document.getElementById('interfaces_manual_container');
                if (interfacesManualContainer) {
                  console.log('Hiding additional interfaces container');
                  interfacesManualContainer.style.display = 'none';
                  console.log('Additional interfaces container display:', interfacesManualContainer.style.display);
                } else {
                  console.error('Additional interfaces container not found!');
                }
                
                // Hide "Combined selection" message in sync mode
                const combinedSelectionMsg = document.getElementById('combined-selection-message');
                if (combinedSelectionMsg) {
                  combinedSelectionMsg.style.display = 'none';
                  console.log('Hiding combined selection message');
                }
                
                if (interfacesManualField) {
                  interfacesManualField.disabled = true;
                }
                
                // Show sync mode info
                if (syncModeInfo) {
                  syncModeInfo.style.display = 'block';
                }

                // Hide deploy untagged interfaces checkbox in sync mode
                if (deployUntaggedContainer) {
                  deployUntaggedContainer.style.display = 'none';
                }

                // Load interfaces for sync if devices are already selected
                // Check native select, Select2, and TomSelect
                let hasSelectedDevices = false;
                if (devicesSelect) {
                  // Check native select
                  if (devicesSelect.selectedOptions && devicesSelect.selectedOptions.length > 0) {
                    hasSelectedDevices = true;
                  }
                  // Check Select2 (if initialized and jQuery is available)
                  if (!hasSelectedDevices && typeof jQuery !== 'undefined' && jQuery(devicesSelect).data('select2')) {
                    const select2Value = jQuery(devicesSelect).val();
                    if (select2Value && (Array.isArray(select2Value) ? select2Value.length > 0 : select2Value)) {
                      hasSelectedDevices = true;
                    }
                  }
                  // Check TomSelect (NetBox's default)
                  if (!hasSelectedDevices && devicesSelect.tomselect) {
                    const tomSelectValue = devicesSelect.tomselect.getValue();
                    if (tomSelectValue && (Array.isArray(tomSelectValue) ? tomSelectValue.length > 0 : tomSelectValue)) {
                      hasSelectedDevices = true;
                    }
                  }
                }
                
                if (hasSelectedDevices) {
                  loadInterfacesForSync();
                } else {
                  interfacesContainer.innerHTML = '<p class="text-muted mb-0" style="color: var(--nbx-color-fg-default) !important; opacity: 1 !important;">Select devices first to load interfaces from NetBox</p>';
                }
              } else {
                console.log('>>> REMOVING SYNC MODE - showing VLAN fields');
                
                // Show VLAN configuration container (normal mode)
                if (vlanConfigContainer) {
                  console.log('Showing VLAN config container');
                  vlanConfigContainer.style.display = 'block';
                  vlanConfigContainer.style.visibility = 'visible';
                  vlanConfigContainer.style.height = 'auto';
                  vlanConfigContainer.style.overflow = 'visible';
                  vlanConfigContainer.removeAttribute('style');
                  vlanConfigContainer.classList.remove('hidden-by-sync');
                  console.log('VLAN container shown and class removed');
                }
                
                // Show and enable fields
                if (untaggedVlanField) {
                  untaggedVlanField.disabled = false;
                  const untaggedContainer = untaggedVlanField.closest('.mb-3');
                  if (untaggedContainer) {
                    untaggedContainer.setAttribute('style', 'display: block !important;');
                  }
                }
                if (taggedVlansField) {
                  taggedVlansField.disabled = false;
                  const taggedContainer = taggedVlansField.closest('.mb-3');
                  if (taggedContainer) {
                    taggedContainer.setAttribute('style', 'display: block !important;');
                  }
                }
                
                // Show additional interfaces field and its container
                const interfacesManualContainer = document.getElementById('interfaces_manual_container');
                if (interfacesManualContainer) {
                  console.log('Showing additional interfaces container');
                  interfacesManualContainer.style.display = 'block';
                  console.log('Additional interfaces container display:', interfacesManualContainer.style.display);
                } else {
                  console.error('Additional interfaces container not found when removing sync mode!');
                }
                
                // Show "Combined selection" message in normal mode
                const combinedSelectionMsg = document.getElementById('combined-selection-message');
                if (combinedSelectionMsg) {
                  combinedSelectionMsg.style.display = 'block';
                  console.log('Showing combined selection message');
                }
                
                if (interfacesManualField) {
                  interfacesManualField.disabled = false;
                }
                
                // Hide sync mode info and show deploy untagged checkbox in normal mode
                if (syncModeInfo) {
                  syncModeInfo.style.display = 'none';
                }
                if (deployUntaggedContainer) {
                  deployUntaggedContainer.style.display = 'block';
                }
                
                // Load interfaces normally if devices are already selected
                // Check native select, Select2, and TomSelect
                let hasSelectedDevices = false;
                if (devicesSelect) {
                  // Check native select
                  if (devicesSelect.selectedOptions && devicesSelect.selectedOptions.length > 0) {
                    hasSelectedDevices = true;
                  }
                  // Check Select2 (if initialized and jQuery is available)
                  if (!hasSelectedDevices && typeof jQuery !== 'undefined' && jQuery(devicesSelect).data('select2')) {
                    const select2Value = jQuery(devicesSelect).val();
                    if (select2Value && (Array.isArray(select2Value) ? select2Value.length > 0 : select2Value)) {
                      hasSelectedDevices = true;
                    }
                  }
                  // Check TomSelect (NetBox's default)
                  if (!hasSelectedDevices && devicesSelect.tomselect) {
                    const tomSelectValue = devicesSelect.tomselect.getValue();
                    if (tomSelectValue && (Array.isArray(tomSelectValue) ? tomSelectValue.length > 0 : tomSelectValue)) {
                      hasSelectedDevices = true;
                    }
                  }
                }
                
                if (hasSelectedDevices) {
                  loadCommonInterfaces();
                } else {
                  interfacesContainer.innerHTML = '<p class="text-muted mb-0" style="color: var(--nbx-color-fg-default) !important; opacity: 1 !important;">Select devices first to load interfaces</p>';
                }
              }
            }

            // Helper function to format interface config info (for sync mode)
            function formatInterfaceConfig(iface) {
              let parts = [];
              if (iface.mode) parts.push(`Mode: ${iface.mode}`);
              if (iface.untagged_vlan) parts.push(`Untagged: ${iface.untagged_vlan.vid}`);
              if (iface.tagged_vlans && iface.tagged_vlans.length > 0) {
                const vlanList = iface.tagged_vlans.map(v => v.vid).join(', ');
                parts.push(`Tagged: ${vlanList}`);
              }
              return parts.join(', ') || 'No VLAN config';
            }

            // Render interfaces in accordion format (for both normal and sync modes)
            function renderInterfacesAccordion(interfacesByDevice, container, syncMode = false, sectionLabel = 'Interfaces grouped by device') {
              container.innerHTML = '';
              
              if (!interfacesByDevice || Object.keys(interfacesByDevice).length === 0) {
                const p = document.createElement('p');
                p.className = 'text-muted mb-0';
                p.style.color = 'var(--nbx-color-fg-default)';
                p.style.opacity = '1';
                p.textContent = syncMode ? 'No interfaces with VLAN configuration found' : 'No interfaces found';
                container.appendChild(p);
                return;
              }
              
              // Create accordion
              const accordionId = 'interfacesAccordion_' + Date.now();
              const accordion = document.createElement('div');
              accordion.className = 'accordion';
              accordion.id = accordionId;
              
              // Add Expand All / Collapse All buttons
              const buttonDiv = document.createElement('div');
              buttonDiv.className = 'mb-2 d-flex justify-content-between align-items-center';
              buttonDiv.innerHTML = `
                <span class="text-muted small" style="color: var(--nbx-color-fg-default);">${sectionLabel}</span>
                <div>
                  <button type="button" class="btn btn-sm btn-outline-secondary" onclick="expandAllAccordion('${accordionId}')">
                    <i class="mdi mdi-chevron-double-down"></i> Expand All
                  </button>
                  <button type="button" class="btn btn-sm btn-outline-secondary" onclick="collapseAllAccordion('${accordionId}')">
                    <i class="mdi mdi-chevron-double-up"></i> Collapse All
                  </button>
                </div>
              `;
              accordion.appendChild(buttonDiv);
              
              // Add accordion items for each device
              let deviceIndex = 0;
              for (const [deviceName, interfaces] of Object.entries(interfacesByDevice)) {
                if (!interfaces || interfaces.length === 0) continue;
                
                const isFirst = deviceIndex === 0;
                const collapseId = `collapse_${deviceIndex}_${accordionId}`;
                const headingId = `heading_${deviceIndex}_${accordionId}`;
                
                const accordionItem = document.createElement('div');
                accordionItem.className = 'accordion-item';
                
                // Header
                const header = document.createElement('h2');
                header.className = 'accordion-header';
                header.id = headingId;
                
                const button = document.createElement('button');
                button.className = `accordion-button ${isFirst ? '' : 'collapsed'}`;
                button.type = 'button';
                button.setAttribute('data-bs-toggle', 'collapse');
                button.setAttribute('data-bs-target', `#${collapseId}`);
                button.setAttribute('aria-expanded', isFirst ? 'true' : 'false');
                button.setAttribute('aria-controls', collapseId);
                // Set button style - device name will have vibrant color, rest of button uses default
                const isDarkMode = document.documentElement.getAttribute('data-theme') === 'dark' || document.body.classList.contains('dark-mode');
                const textColor = isDarkMode ? 'var(--nbx-color-fg-default, #ffffff)' : 'var(--nbx-color-fg-default)';
                
                // Apply default text color to button (device name will override with vibrant color)
                button.style.setProperty('color', textColor, 'important');
                
                // Create strong element with vibrant color that works in both light and dark modes
                const strongEl = document.createElement('strong');
                strongEl.className = 'device-name';
                
                // Vibrant colors that work in both light and dark modes
                // Cycle through colors for visual distinction between devices
                const vibrantColors = [
                  '#0d6efd',  // Bootstrap primary blue - vibrant and visible in both modes
                  '#198754',  // Bootstrap success green - vibrant and visible
                  '#dc3545',  // Bootstrap danger red - vibrant and visible
                  '#fd7e14',  // Bootstrap warning orange - vibrant and visible
                  '#6f42c1',  // Bootstrap info purple - vibrant and visible
                  '#20c997',  // Bootstrap info teal - vibrant and visible
                  '#0dcaf0',  // Bootstrap info cyan - vibrant and visible
                  '#ffc107',  // Bootstrap warning yellow - vibrant (darker in dark mode)
                ];
                
                // Use device index to cycle through colors
                const colorIndex = deviceIndex % vibrantColors.length;
                const deviceColor = vibrantColors[colorIndex];
                
                // Apply vibrant color - works in both light and dark modes
                strongEl.style.setProperty('color', deviceColor, 'important');
                strongEl.style.setProperty('font-weight', '600', 'important');
                strongEl.style.setProperty('text-shadow', isDarkMode ? '0 1px 2px rgba(0,0,0,0.3)' : 'none', 'important');
                strongEl.textContent = deviceName;
                
                const badgeSpan = document.createElement('span');
                badgeSpan.className = 'badge bg-secondary ms-2';
                badgeSpan.textContent = `${interfaces.length} interface${interfaces.length !== 1 ? 's' : ''}`;
                
                button.appendChild(strongEl);
                button.appendChild(badgeSpan);
                
                // Ensure device name color persists (vibrant color already set above)
                // Use MutationObserver to maintain vibrant color if DOM changes
                const maintainDeviceColor = () => {
                  // Ensure device name keeps its vibrant color
                  if (strongEl && strongEl.classList.contains('device-name')) {
                    const colorIndex = deviceIndex % vibrantColors.length;
                    const deviceColor = vibrantColors[colorIndex];
                    strongEl.style.setProperty('color', deviceColor, 'important');
                  }
                };
                
                // Apply immediately
                maintainDeviceColor();
                
                // Watch for changes and reapply if needed
                if (isDarkMode) {
                  const observer = new MutationObserver(() => {
                    maintainDeviceColor();
                  });
                  
                  observer.observe(button, {
                    attributes: true,
                    attributeFilter: ['style', 'class'],
                    childList: true,
                    subtree: true
                  });
                  
                  // Also force reapply after a short delay to catch any late DOM changes
                  setTimeout(() => {
                    maintainDeviceColor();
                  }, 100);
                  
                  // Store observer on element for cleanup if needed
                  button._colorObserver = observer;
                } else {
                  // Light mode: also maintain vibrant color
                  const observer = new MutationObserver(() => {
                    maintainDeviceColor();
                  });
                  
                  observer.observe(button, {
                    attributes: true,
                    attributeFilter: ['style', 'class'],
                    childList: true,
                    subtree: true
                  });
                  
                  setTimeout(() => {
                    maintainDeviceColor();
                  }, 100);
                  
                  button._colorObserver = observer;
                }
                header.appendChild(button);
                
                // Body
                const collapse = document.createElement('div');
                collapse.id = collapseId;
                collapse.className = `accordion-collapse collapse ${isFirst ? 'show' : ''}`;
                collapse.setAttribute('aria-labelledby', headingId);
                collapse.setAttribute('data-bs-parent', `#${accordionId}`);
                
                const body = document.createElement('div');
                body.className = 'accordion-body';
                
                // Add checkboxes for each interface
                interfaces.forEach(iface => {
                  const checked = syncMode ? 'checked' : '';
                  const ifaceName = typeof iface === 'string' ? iface : (iface.name || iface);
                  const configInfo = syncMode && typeof iface === 'object' ? formatInterfaceConfig(iface) : '';
                  const checkboxValue = syncMode ? `${deviceName}:${ifaceName}` : ifaceName;
                  
                  // Extract interface metadata for display
                  const hasWarning = syncMode && typeof iface === 'object' && iface.has_conflicting_tags;
                  const warningText = syncMode && typeof iface === 'object' && iface.warning ? iface.warning : '';
                  const infoText = syncMode && typeof iface === 'object' && iface.info ? iface.info : '';
                  const conflictingTags = syncMode && typeof iface === 'object' && iface.conflicting_tags ? iface.conflicting_tags : [];
                  const otherTags = syncMode && typeof iface === 'object' && iface.other_tags ? iface.other_tags : [];
                  const vlanModeTags = syncMode && typeof iface === 'object' && iface.vlan_mode_tags ? iface.vlan_mode_tags : [];
                  const hasAnyTags = syncMode && typeof iface === 'object' && iface.has_any_tags !== undefined ? iface.has_any_tags : false;
                  const isSection1 = vlanModeTags.length > 0; // Section 1 interfaces have vlan-mode tags
                  
                  const checkboxId = `iface_${deviceIndex}_${ifaceName.replace(/[^a-zA-Z0-9]/g, '_')}`;
                  
                  const formCheck = document.createElement('div');
                  formCheck.className = 'form-check mb-3';
                  
                  const checkbox = document.createElement('input');
                  checkbox.type = 'checkbox';
                  checkbox.className = 'form-check-input';
                  checkbox.name = 'interfaces_select';
                  checkbox.value = checkboxValue;
                  checkbox.id = checkboxId;
                  if (checked) checkbox.checked = true;
                  
                  const labelWrapper = document.createElement('div');
                  labelWrapper.className = 'd-flex align-items-start flex-wrap';
                  
                  const label = document.createElement('label');
                  label.className = 'form-check-label me-2';
                  label.htmlFor = checkboxId;
                  // Set explicit color based on dark mode
                  if (document.documentElement.getAttribute('data-theme') === 'dark' || document.body.classList.contains('dark-mode')) {
                    label.style.color = '#ffffff';
                  } else {
                    label.style.color = 'var(--nbx-color-fg-default)';
                  }
                  // Ensure all child elements (strong, span) inherit the color
                  const strongColor = (document.documentElement.getAttribute('data-theme') === 'dark' || document.body.classList.contains('dark-mode')) ? '#ffffff' : 'var(--nbx-color-fg-default)';
                  label.innerHTML = `<strong style="color: ${strongColor} !important;">${ifaceName}</strong>${configInfo ? `<span class="text-muted small ms-2" style="color: var(--nbx-color-fg-muted, ${strongColor});">${configInfo}</span>` : ''}`;
                  
                  labelWrapper.appendChild(label);
                  
                  // Add tag badges to show interface status
                  if (syncMode && typeof iface === 'object') {
                    const tagsDiv = document.createElement('div');
                    tagsDiv.className = 'd-flex flex-wrap gap-1 ms-2';
                    let hasBadges = false;
                    
                    // Section 1: Show vlan-mode:access or vlan-mode:tagged badges
                    if (isSection1 && vlanModeTags.length > 0) {
                      vlanModeTags.forEach(tagName => {
                        const badge = document.createElement('span');
                        // vlan-mode:access = success (green), vlan-mode:tagged = info (blue)
                        if (tagName.startsWith('vlan-mode:access')) {
                          badge.className = 'badge bg-success';
                        } else if (tagName.startsWith('vlan-mode:tagged')) {
                          badge.className = 'badge bg-info';
                        } else {
                          badge.className = 'badge bg-secondary';
                        }
                        badge.textContent = tagName;
                        badge.title = 'Interface tag';
                        tagsDiv.appendChild(badge);
                        hasBadges = true;
                      });
                    }
                    // Section 2: Show conflicting tags (danger) or other tags (info) or untagged badge
                    else {
                      if (conflictingTags.length > 0) {
                        conflictingTags.forEach(tagName => {
                          const badge = document.createElement('span');
                          badge.className = 'badge bg-danger';
                          badge.textContent = tagName;
                          badge.title = 'This tag will be replaced';
                          tagsDiv.appendChild(badge);
                          hasBadges = true;
                        });
                      }
                      
                      if (otherTags.length > 0) {
                        otherTags.forEach(tagName => {
                          const badge = document.createElement('span');
                          badge.className = 'badge bg-info';
                          badge.textContent = tagName;
                          badge.title = 'Existing tag (will not be removed)';
                          tagsDiv.appendChild(badge);
                          hasBadges = true;
                        });
                      }
                      
                      if (!hasAnyTags) {
                        // No tags - show "Untagged" badge
                        const untaggedBadge = document.createElement('span');
                        untaggedBadge.className = 'badge bg-secondary';
                        untaggedBadge.textContent = 'Untagged';
                        untaggedBadge.title = 'No tags - will be auto-tagged after deployment';
                        tagsDiv.appendChild(untaggedBadge);
                        hasBadges = true;
                      }
                    }
                    
                    if (hasBadges) {
                      labelWrapper.appendChild(tagsDiv);
                    }
                  }
                  
                  formCheck.appendChild(checkbox);
                  formCheck.appendChild(labelWrapper);
                  
                  // Add warning/info messages below the interface
                  if (hasWarning && warningText) {
                    const warningDiv = document.createElement('div');
                    warningDiv.className = 'alert alert-warning alert-sm mt-2 mb-0 ms-4';
                    warningDiv.style.fontSize = '0.85rem';
                    warningDiv.style.padding = '0.5rem 0.75rem';
                    // Use NetBox CSS variables - they handle dark mode automatically
                    warningDiv.innerHTML = `<i class="mdi mdi-alert"></i> <strong>Warning:</strong> ${warningText}`;
                    formCheck.appendChild(warningDiv);
                  } else if (infoText) {
                    const infoDiv = document.createElement('div');
                    infoDiv.className = 'alert alert-info alert-sm mt-2 mb-0 ms-4';
                    infoDiv.style.fontSize = '0.85rem';
                    infoDiv.style.padding = '0.5rem 0.75rem';
                    // Use NetBox CSS variables - they handle dark mode automatically
                    infoDiv.innerHTML = `<i class="mdi mdi-information"></i> ${infoText}`;
                    formCheck.appendChild(infoDiv);
                  }
                  
                  body.appendChild(formCheck);
                });
                
                collapse.appendChild(body);
                accordionItem.appendChild(header);
                accordionItem.appendChild(collapse);
                accordion.appendChild(accordionItem);
                
                deviceIndex++;
              }
              
              container.appendChild(accordion);
              
              // Add helper functions for Expand All / Collapse All (always define to ensure they work)
              window.expandAllAccordion = function(accordionId) {
                const accordion = document.getElementById(accordionId);
                if (!accordion) return;
                const collapses = accordion.querySelectorAll('.accordion-collapse');
                collapses.forEach(collapse => {
                  // Check if Bootstrap Collapse is available
                  if (typeof bootstrap !== 'undefined' && bootstrap.Collapse) {
                    const bsCollapse = new bootstrap.Collapse(collapse, { toggle: false });
                    bsCollapse.show();
                  } else {
                    // Fallback: manually add 'show' class
                    collapse.classList.add('show');
                  }
                });
              };
              window.collapseAllAccordion = function(accordionId) {
                const accordion = document.getElementById(accordionId);
                if (!accordion) return;
                const collapses = accordion.querySelectorAll('.accordion-collapse');
                collapses.forEach(collapse => {
                  // Check if Bootstrap Collapse is available
                  if (typeof bootstrap !== 'undefined' && bootstrap.Collapse) {
                    const bsCollapse = new bootstrap.Collapse(collapse, { toggle: false });
                    bsCollapse.hide();
                  } else {
                    // Fallback: manually remove 'show' class
                    collapse.classList.remove('show');
                  }
                });
              };
            }

            // Render sync mode interfaces in two sections (tagged and untagged)
            function renderSyncModeInterfaces(data, container) {
              container.innerHTML = '';
              
              const taggedInterfaces = data.tagged_interfaces || {};
              const untaggedInterfaces = data.untagged_interfaces || {};
              const totalTagged = data.total_tagged || 0;
              const totalUntagged = data.total_untagged || 0;
              
              const hasTagged = totalTagged > 0 || Object.keys(taggedInterfaces).length > 0;
              const hasUntagged = totalUntagged > 0 || Object.keys(untaggedInterfaces).length > 0;
              
              // Scenario: Both sections are empty
              if (!hasTagged && !hasUntagged) {
                const emptyDiv = document.createElement('div');
                emptyDiv.className = 'alert alert-info mb-0';
                emptyDiv.innerHTML = `
                  <strong><i class="mdi mdi-information"></i> No interfaces with VLAN configuration found</strong>
                  <p class="mb-2 mt-2">No interfaces matching your criteria were found. Make sure:</p>
                  <ul class="mb-0">
                    <li>Devices have interfaces with VLAN configuration in NetBox</li>
                    <li>Interfaces have VLAN configuration (untagged_vlan or tagged_vlans)</li>
                  </ul>
                `;
                container.appendChild(emptyDiv);
                return;
              }
              
              // Section 1: Tagged Interfaces
              if (hasTagged) {
                const section1Div = document.createElement('div');
                section1Div.className = 'mb-4';
                
                const section1Header = document.createElement('h5');
                section1Header.className = 'mb-3';
                section1Header.style.color = 'var(--nbx-color-fg-default)';
                section1Header.innerHTML = `
                  Section 1: Tagged Interfaces (vlan-mode:access or vlan-mode:tagged)
                  <span class="badge bg-success ms-2">${totalTagged} interface${totalTagged !== 1 ? 's' : ''}</span>
                `;
                section1Div.appendChild(section1Header);
                
                renderInterfacesAccordion(taggedInterfaces, section1Div, true, 'Tagged interfaces grouped by device');
                
                // If Section 1 has items but Section 2 is empty, show info message
                if (hasTagged && !hasUntagged) {
                  const infoDiv = document.createElement('div');
                  infoDiv.className = 'alert alert-success mb-0 mt-3';
                  infoDiv.style.fontSize = '0.9rem';
                  infoDiv.innerHTML = `
                    <i class="mdi mdi-information"></i> 
                    <strong>All interfaces are already tagged.</strong> 
                    No untagged interfaces found - all interfaces have <code>vlan-mode:access</code> or <code>vlan-mode:tagged</code> tags.
                  `;
                  section1Div.appendChild(infoDiv);
                }
                
                container.appendChild(section1Div);
              }
              
              // Section 2: Interfaces with VLAN config but not tagged as access/tagged (only show if it has interfaces)
              if (hasUntagged) {
                const section2Div = document.createElement('div');
                section2Div.className = 'mb-4';
                
                const totalConflicting = data.total_conflicting || 0;
                const section2Header = document.createElement('h5');
                section2Header.className = 'mb-3';
                section2Header.style.color = 'var(--nbx-color-fg-default)';
                section2Header.innerHTML = `
                  Section 2: Interfaces with VLAN Config (untagged or labeled differently - will be auto-tagged/re-labeled after deployment)
                  <span class="badge bg-warning ms-2">${totalUntagged} interface${totalUntagged !== 1 ? 's' : ''}</span>
                  ${totalConflicting > 0 ? `<span class="badge bg-danger ms-2">${totalConflicting} with conflicting tags</span>` : ''}
                `;
                section2Div.appendChild(section2Header);
                
                // Add checkbox for deploying on untagged interfaces
                const deployUntaggedCheckbox = document.getElementById('id_deploy_untagged_interfaces');
                if (deployUntaggedCheckbox) {
                  deployUntaggedCheckbox.checked = true; // Pre-check by default
                }
                
                renderInterfacesAccordion(untaggedInterfaces, section2Div, true, 'Untagged interfaces grouped by device');
                container.appendChild(section2Div);
              }
            }

            // Helper function to render interface checkboxes (legacy - for backward compatibility)
            function renderInterfaceCheckboxes(interfaces, container) {
              // If interfaces is an object (grouped by device), use accordion
              if (typeof interfaces === 'object' && !Array.isArray(interfaces)) {
                renderInterfacesAccordion(interfaces, container, false);
                return;
              }
              
              // Otherwise, render as flat list (backward compatibility)
              container.innerHTML = '';
              
              if (!interfaces || interfaces.length === 0) {
                const p = document.createElement('p');
                p.className = 'text-muted mb-0';
                p.style.color = 'var(--nbx-color-fg-default)';
                p.style.opacity = '1';
                p.textContent = 'No interfaces found';
                container.appendChild(p);
                return;
              }
              
              // Create checkboxes for each interface
              interfaces.forEach(iface => {
                const div = document.createElement('div');
                div.className = 'form-check';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'form-check-input';
                checkbox.name = 'interfaces_select';
                checkbox.value = iface;
                checkbox.id = `interface_${iface}`;

                const label = document.createElement('label');
                label.className = 'form-check-label';
                label.style.color = window.getNetBoxTextColor ? window.getNetBoxTextColor() : (isDarkMode() ? '#ffffff' : '#212529');
                label.htmlFor = `interface_${iface}`;
                label.textContent = iface;

                div.appendChild(checkbox);
                div.appendChild(label);
                container.appendChild(div);
              });
            }

            // Load interfaces for sync mode
            function loadInterfacesForSync() {
              console.log('loadInterfacesForSync called');
              const devicesSelect = document.getElementById('id_devices');
              const interfacesContainer = document.getElementById('interfaces-checkbox-container');
              
              // Get selected device IDs - handle both native select, Select2, and TomSelect
              let selectedDeviceIds = [];
              if (devicesSelect) {
                // Try native select first
                if (devicesSelect.selectedOptions && devicesSelect.selectedOptions.length > 0) {
                  selectedDeviceIds = Array.from(devicesSelect.selectedOptions).map(opt => opt.value);
                }
                // If Select2 is used, get values from Select2
                if ((selectedDeviceIds.length === 0) && typeof jQuery !== 'undefined' && jQuery(devicesSelect).data('select2')) {
                  const select2Value = jQuery(devicesSelect).val();
                  if (select2Value && Array.isArray(select2Value)) {
                    selectedDeviceIds = select2Value;
                  } else if (select2Value) {
                    selectedDeviceIds = [select2Value];
                  }
                }
                // If TomSelect is used (NetBox's default), get values from TomSelect
                if ((selectedDeviceIds.length === 0) && devicesSelect.tomselect) {
                  const tomSelectValue = devicesSelect.tomselect.getValue();
                  if (tomSelectValue) {
                    selectedDeviceIds = Array.isArray(tomSelectValue) ? tomSelectValue : [tomSelectValue];
                  }
                }
              }

              console.log('Selected device IDs:', selectedDeviceIds);

              if (selectedDeviceIds.length === 0) {
                const p = document.createElement('p');
                p.className = 'text-muted mb-0';
                p.style.color = 'var(--nbx-color-fg-default)';
                p.style.opacity = '1';
                p.textContent = 'Select devices first to load interfaces from NetBox';
                interfacesContainer.innerHTML = '';
                interfacesContainer.appendChild(p);
                return;
              }

              // Show loading
              const loadingP = document.createElement('p');
              loadingP.className = 'text-muted mb-0';
              loadingP.style.color = window.getNetBoxTextColor ? window.getNetBoxTextColor() : (isDarkMode() ? '#ffffff' : '#212529');
              loadingP.style.opacity = '1';
              loadingP.textContent = 'Loading interfaces from NetBox...';
              interfacesContainer.innerHTML = '';
              interfacesContainer.appendChild(loadingP);

              // Build query string
              const params = new URLSearchParams();
              selectedDeviceIds.forEach(id => params.append('device_ids[]', id));

              const url = `/plugins/automation/vlan-deployment/get-interfaces-for-sync/?${params.toString()}`;
              console.log('Fetching interfaces for sync from:', url);

              // Fetch interfaces with VLAN config
              fetch(url)
                .then(response => {
                  console.log('Sync interface response status:', response.status);
                  return response.json();
                })
                .then(data => {
                  console.log('Sync interface data received:', data);
                  
                  if (data.error) {
                    const errorP = document.createElement('p');
                    errorP.className = 'text-danger mb-0';
                    errorP.style.color = 'var(--nbx-color-danger, #dc3545)';
                    errorP.textContent = 'Error: ' + data.error;
                    interfacesContainer.innerHTML = '';
                    interfacesContainer.appendChild(errorP);
                    return;
                  }
                  
                  // Render two sections: tagged and untagged
                  renderSyncModeInterfaces(data, interfacesContainer);
                })
                .catch(error => {
                  console.error('Error loading interfaces for sync:', error);
                  const errorP = document.createElement('p');
                  errorP.className = 'text-danger mb-0';
                  errorP.style.color = 'var(--nbx-color-danger, #dc3545)';
                  errorP.textContent = 'Error loading interfaces';
                  interfacesContainer.innerHTML = '';
                  interfacesContainer.appendChild(errorP);
                });
            }

            // Load interfaces and populate checkboxes when devices are selected (Normal mode)
            function loadCommonInterfaces() {
              console.log('loadCommonInterfaces called');
              const devicesSelect = document.getElementById('id_devices');
              const interfacesContainer = document.getElementById('interfaces-checkbox-container');
              
              // Get selected device IDs - handle both native select, Select2, and TomSelect
              let selectedDeviceIds = [];
              if (devicesSelect) {
                // Try native select first
                if (devicesSelect.selectedOptions && devicesSelect.selectedOptions.length > 0) {
                  selectedDeviceIds = Array.from(devicesSelect.selectedOptions).map(opt => opt.value);
                }
                // If Select2 is used, get values from Select2
                if ((selectedDeviceIds.length === 0) && typeof jQuery !== 'undefined' && jQuery(devicesSelect).data('select2')) {
                  const select2Value = jQuery(devicesSelect).val();
                  if (select2Value && Array.isArray(select2Value)) {
                    selectedDeviceIds = select2Value;
                  } else if (select2Value) {
                    selectedDeviceIds = [select2Value];
                  }
                }
                // If TomSelect is used (NetBox's default), get values from TomSelect
                if ((selectedDeviceIds.length === 0) && devicesSelect.tomselect) {
                  const tomSelectValue = devicesSelect.tomselect.getValue();
                  if (tomSelectValue) {
                    selectedDeviceIds = Array.isArray(tomSelectValue) ? tomSelectValue : [tomSelectValue];
                  }
                }
              }

              console.log('Selected device IDs:', selectedDeviceIds);

              if (selectedDeviceIds.length === 0) {
                const p = document.createElement('p');
                p.className = 'text-muted mb-0';
                p.style.color = 'var(--nbx-color-fg-default)';
                p.style.opacity = '1';
                p.textContent = 'Select devices first to load interfaces';
                interfacesContainer.innerHTML = '';
                interfacesContainer.appendChild(p);
                return;
              }

              // Show loading
              const loadingP = document.createElement('p');
              loadingP.className = 'text-muted mb-0';
              loadingP.style.color = window.getNetBoxTextColor ? window.getNetBoxTextColor() : (isDarkMode() ? '#ffffff' : '#212529');
              loadingP.style.opacity = '1';
              loadingP.textContent = 'Loading interfaces...';
              interfacesContainer.innerHTML = '';
              interfacesContainer.appendChild(loadingP);

              // Build query string
              const params = new URLSearchParams();
              selectedDeviceIds.forEach(id => params.append('device_ids[]', id));

              const url = `/plugins/automation/vlan-deployment/get-interfaces/?${params.toString()}`;
              console.log('Fetching interfaces from:', url);

              // Fetch interfaces (now returns grouped by device)
              fetch(url)
                .then(response => {
                  console.log('Interface response status:', response.status);
                  return response.json();
                })
                .then(data => {
                  console.log('Interface data received:', data);
                  
                  // Use accordion format (interfaces_by_device)
                  if (data.interfaces_by_device) {
                    renderInterfacesAccordion(data.interfaces_by_device, interfacesContainer, false);
                  } else if (data.interfaces) {
                    // Backward compatibility: if old format, render as flat list
                  renderInterfaceCheckboxes(data.interfaces, interfacesContainer);
                  }

                  // Also filter VLANs by site of selected devices (only in normal mode, not sync mode)
                  const syncCheckbox = document.getElementById('id_sync_netbox_to_device');
                  if (!syncCheckbox || !syncCheckbox.checked) {
                    console.log('About to call filterVLANsByDevices with:', selectedDeviceIds);
                    if (selectedDeviceIds && selectedDeviceIds.length > 0) {
                      setTimeout(() => {
                        filterVLANsByDevices(selectedDeviceIds);
                      }, 200);
                    } else {
                      console.warn('No device IDs to filter VLANs');
                    }
                  }
                })
                .catch(error => {
                  console.error('Error loading interfaces:', error);
                  const errorP = document.createElement('p');
                  errorP.className = 'text-danger mb-0';
                  errorP.style.color = 'var(--nbx-color-danger, #dc3545)';
                  errorP.textContent = 'Error loading interfaces';
                  interfacesContainer.innerHTML = '';
                  interfacesContainer.appendChild(errorP);
                });
            }

            // Load interfaces for Group mode (Site + Location + Manufacturer + Role)
            function loadInterfacesFromGroupFilters() {
              console.log('loadInterfacesFromGroupFilters called');
              
              const siteSelect = document.getElementById('id_site');
              const locationSelect = document.getElementById('id_location');
              const manufacturerSelect = document.getElementById('id_manufacturer');
              const roleSelect = document.getElementById('id_role');
              const excludedDevicesSelect = document.getElementById('id_excluded_devices');
              const interfacesContainer = document.getElementById('interfaces-checkbox-container');
              const syncCheckbox = document.getElementById('id_sync_netbox_to_device');
              const isSyncMode = syncCheckbox && syncCheckbox.checked;
              
              const siteId = siteSelect ? siteSelect.value : '';
              const locationId = locationSelect ? locationSelect.value : '';
              const manufacturerId = manufacturerSelect ? manufacturerSelect.value : '';
              const roleId = roleSelect ? roleSelect.value : '';
              
              // Get excluded device IDs
              let excludedDeviceIds = [];
              if (excludedDevicesSelect) {
                if (excludedDevicesSelect.selectedOptions) {
                  excludedDeviceIds = Array.from(excludedDevicesSelect.selectedOptions).map(opt => opt.value);
                } else if (typeof jQuery !== 'undefined' && jQuery(excludedDevicesSelect).data('select2')) {
                  excludedDeviceIds = jQuery(excludedDevicesSelect).val() || [];
                }
              }
              
              console.log('Group filters:', {siteId, locationId, manufacturerId, roleId, isSyncMode, excludedDeviceIds});
              
              // Only load interfaces if ALL filters are selected
              if (!siteId || !locationId || !manufacturerId || !roleId) {
                const p = document.createElement('p');
                p.className = 'text-muted mb-0';
                p.style.color = 'var(--nbx-color-fg-default)';
                p.style.opacity = '1';
                p.textContent = 'Select all filters (Site, Location, Manufacturer, Role) to load interfaces';
                interfacesContainer.innerHTML = '';
                interfacesContainer.appendChild(p);
                return;
              }
              
              // Show loading
              const loadingP = document.createElement('p');
              loadingP.className = 'text-muted mb-0';
              loadingP.style.color = 'var(--nbx-color-fg-default)';
              loadingP.style.opacity = '1';
              loadingP.textContent = isSyncMode ? 'Loading interfaces from NetBox...' : 'Loading interfaces...';
              interfacesContainer.innerHTML = '';
              interfacesContainer.appendChild(loadingP);
              
              // Choose endpoint based on sync mode
              let url;
              if (isSyncMode) {
                // Sync mode: use sync endpoint with group filters
                const params = new URLSearchParams();
                params.append('site_id', siteId);
                params.append('location_id', locationId);
                params.append('manufacturer_id', manufacturerId);
                params.append('role_id', roleId);
                excludedDeviceIds.forEach(id => params.append('excluded_device_ids[]', id));
                url = `/plugins/automation/vlan-deployment/get-interfaces-for-sync/?${params.toString()}`;
                console.log('Fetching interfaces for sync from:', url);
                
                fetch(url)
                  .then(response => {
                    console.log('Sync interface response status:', response.status);
                    return response.json();
                  })
                  .then(data => {
                    console.log('Sync interface data received:', data);
                    // Render two sections: tagged and untagged
                    renderSyncModeInterfaces(data, interfacesContainer);
                  })
                  .catch(error => {
                    console.error('Error loading interfaces for sync:', error);
                    const errorP = document.createElement('p');
                    errorP.className = 'text-danger mb-0';
                    errorP.style.color = 'var(--nbx-color-danger, #dc3545)';
                    errorP.textContent = 'Error loading interfaces';
                    interfacesContainer.innerHTML = '';
                    interfacesContainer.appendChild(errorP);
                  });
              } else {
                // Normal mode: use normal endpoint
                const params = new URLSearchParams();
                params.append('site_id', siteId);
                params.append('location_id', locationId);
                params.append('manufacturer_id', manufacturerId);
                params.append('role_id', roleId);
                excludedDeviceIds.forEach(id => params.append('excluded_device_ids[]', id));
                url = `/plugins/automation/vlan-deployment/get-interfaces/?${params.toString()}`;
                console.log('Fetching interfaces from:', url);
              
              fetch(url)
                .then(response => {
                  console.log('Interface response status:', response.status);
                  return response.json();
                })
                .then(data => {
                  console.log('Interface data received:', data);
                    console.log(`Found ${data.device_count} devices with interfaces`);
                    
                    // Use accordion format (interfaces_by_device)
                    if (data.interfaces_by_device) {
                      renderInterfacesAccordion(data.interfaces_by_device, interfacesContainer, false);
                    } else if (data.interfaces) {
                      // Backward compatibility: if old format, render as flat list
                  renderInterfaceCheckboxes(data.interfaces, interfacesContainer);
                    }
                  
                  // Also load VLANs for this site
                  filterVLANsBySite();
                })
                .catch(error => {
                  console.error('Error loading interfaces:', error);
                  const errorP = document.createElement('p');
                  errorP.className = 'text-danger mb-0';
                  errorP.style.color = 'var(--nbx-color-danger, #dc3545)';
                  errorP.textContent = 'Error loading interfaces';
                  interfacesContainer.innerHTML = '';
                  interfacesContainer.appendChild(errorP);
                });
              }
            }

            // Filter VLANs by site when devices are selected (single mode)
            function filterVLANsByDevices(deviceIds) {
              console.log('=== filterVLANsByDevices called ===');
              console.log('Device IDs:', deviceIds);

              const untaggedVlanDatalist = document.getElementById('untagged_vlan_datalist');
              const taggedVlansDatalist = document.getElementById('tagged_vlans_datalist');
              
              console.log('Elements found:', {
                untaggedVlanDatalist: !!untaggedVlanDatalist,
                taggedVlansDatalist: !!taggedVlansDatalist
              });

              if (deviceIds.length === 0) {
                // Clear datalists
                if (untaggedVlanDatalist) {
                  untaggedVlanDatalist.innerHTML = '';
                }
                if (taggedVlansDatalist) {
                  taggedVlansDatalist.innerHTML = '';
                }
                return;
              }

              // Build query string with device IDs
              const params = new URLSearchParams();
              deviceIds.forEach(id => params.append('device_ids[]', id));

              const url = `/plugins/automation/vlan-deployment/get-vlans/?${params.toString()}`;
              console.log('Fetching VLANs from:', url);

              // Fetch VLANs for the site of selected devices
              fetch(url)
                .then(response => {
                  console.log('VLAN response status:', response.status);
                  if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                  }
                  return response.json();
                })
                .then(data => {
                  console.log('VLAN data received:', data);
                  console.log('Number of VLANs:', data.vlans ? data.vlans.length : 0);
                  if (data.error) {
                    console.error('API returned error:', data.error);
                    return;
                  }

                  // Populate untagged VLAN datalist
                  if (untaggedVlanDatalist) {
                    if (data.vlans && data.vlans.length > 0) {
                      // Clear existing options
                      untaggedVlanDatalist.innerHTML = '';
                      // Add VLAN options to datalist
                      data.vlans.forEach(vlan => {
                        const option = document.createElement('option');
                        option.value = vlan.vid; // Use VID for datalist (user types VID, not ID)
                        option.textContent = vlan.display || `${vlan.vid} - ${vlan.name || ''}`;
                        untaggedVlanDatalist.appendChild(option);
                      });
                      console.log(` Populated untagged VLAN datalist with ${data.vlans.length} VLANs`);
                    } else {
                      // Clear datalist
                      untaggedVlanDatalist.innerHTML = '';
                      console.log(' No VLANs found for this location - untagged datalist cleared');
                    }
                  } else {
                    console.error(' Untagged VLAN datalist element not found!');
                  }

                  // Populate tagged VLANs datalist
                  if (taggedVlansDatalist) {
                    if (data.vlans && data.vlans.length > 0) {
                      // Clear existing options
                      taggedVlansDatalist.innerHTML = '';
                      // Add VLAN options to datalist
                      data.vlans.forEach(vlan => {
                        const option = document.createElement('option');
                        option.value = vlan.vid; // Use VID for datalist (user types VID, not ID)
                        option.textContent = vlan.display || `${vlan.vid} - ${vlan.name || ''}`;
                        taggedVlansDatalist.appendChild(option);
                      });
                      console.log(` Populated tagged VLANs datalist with ${data.vlans.length} VLANs`);
                    } else {
                      // Clear datalist
                      taggedVlansDatalist.innerHTML = '';
                      console.log(' No VLANs found for this location - tagged datalist cleared');
                    }
                  } else {
                    console.error(' Tagged VLANs datalist element not found!');
                  }
                })
                .catch(error => {
                  console.error('Error loading VLANs:', error);
                });
            }

            // Filter VLANs by site when site is selected (group mode)
            function filterVLANsBySite() {
              console.log('=== filterVLANsBySite called ===');
              
              const siteSelect = document.getElementById('id_site');
              const siteId = siteSelect ? siteSelect.value : '';
              
              console.log('Site ID:', siteId);
              
              const untaggedVlanDatalist = document.getElementById('untagged_vlan_datalist');
              const taggedVlansDatalist = document.getElementById('tagged_vlans_datalist');
              
              console.log('Elements found:', {
                untaggedVlanDatalist: !!untaggedVlanDatalist,
                taggedVlansDatalist: !!taggedVlansDatalist
              });

              if (!siteId) {
                // Clear datalists if no site selected
                if (untaggedVlanDatalist) {
                  untaggedVlanDatalist.innerHTML = '';
                }
                if (taggedVlansDatalist) {
                  taggedVlansDatalist.innerHTML = '';
                }
                return;
              }

              // Fetch VLANs for this site
              fetch(`/plugins/automation/vlan-deployment/get-vlans/?site_id=${siteId}`)
                .then(response => {
                  console.log('VLAN response status:', response.status);
                  if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                  }
                  return response.json();
                })
                .then(data => {
                  console.log('VLAN data received:', data);
                  console.log('Number of VLANs:', data.vlans ? data.vlans.length : 0);
                  if (data.error) {
                    console.error('API returned error:', data.error);
                    return;
                  }
                  // Populate untagged VLAN datalist
                  if (untaggedVlanDatalist) {
                    if (data.vlans && data.vlans.length > 0) {
                      // Clear existing options
                      untaggedVlanDatalist.innerHTML = '';
                      // Add VLAN options to datalist
                      data.vlans.forEach(vlan => {
                        const option = document.createElement('option');
                        option.value = vlan.vid; // Use VID for datalist (user types VID, not ID)
                        option.textContent = vlan.display || `${vlan.vid} - ${vlan.name || ''}`;
                        untaggedVlanDatalist.appendChild(option);
                      });
                      console.log(` Populated untagged VLAN datalist with ${data.vlans.length} VLANs from site`);
                    } else {
                      // Clear datalist
                      untaggedVlanDatalist.innerHTML = '';
                      console.log(' No VLANs found for this site - untagged datalist cleared');
                    }
                  } else {
                    console.error(' Untagged VLAN datalist element not found!');
                  }

                  // Populate tagged VLANs datalist
                  if (taggedVlansDatalist) {
                    if (data.vlans && data.vlans.length > 0) {
                      // Clear existing options
                      taggedVlansDatalist.innerHTML = '';
                      // Add VLAN options to datalist
                      data.vlans.forEach(vlan => {
                        const option = document.createElement('option');
                        option.value = vlan.vid; // Use VID for datalist (user types VID, not ID)
                        option.textContent = vlan.display || `${vlan.vid} - ${vlan.name || ''}`;
                        taggedVlansDatalist.appendChild(option);
                      });
                      console.log(` Populated tagged VLANs datalist with ${data.vlans.length} VLANs from site`);
                    } else {
                      // Clear datalist
                      taggedVlansDatalist.innerHTML = '';
                      console.log(' No VLANs found for this site - tagged datalist cleared');
                    }
                  } else {
                    console.error(' Tagged VLANs datalist element not found!');
                  }
                })
                .catch(error => {
                  console.error('Error loading VLANs:', error);
                });
            }

            // Update deploy button state (enabled/disabled and text)
            function updateDeployButtonState() {
              const dryRunCheckbox = document.getElementById('id_dry_run');
              const deployCheckbox = document.getElementById('id_deploy_changes');
              const deployBtn = document.getElementById('deploy-btn');
              const deployBtnText = document.getElementById('deploy-btn-text');

              if (dryRunCheckbox && deployCheckbox && deployBtn && deployBtnText) {
                const isAnySelected = dryRunCheckbox.checked || deployCheckbox.checked;
                
                // Enable/disable button based on selection
                deployBtn.disabled = !isAnySelected;
                
                // Update button text
                if (dryRunCheckbox.checked) {
                  deployBtnText.textContent = 'Deploy VLAN Dryrun';
                } else if (deployCheckbox.checked) {
                  deployBtnText.textContent = 'Deploy VLAN';
                } else {
                  deployBtnText.textContent = 'Deploy VLAN';
                }
              }
            }
            
            // Update deploy button text based on selected mode (legacy function name for compatibility)
            function updateDeployButtonText() {
              updateDeployButtonState();
            }

            // Make Dry Run and Deploy Changes mutually exclusive
            function setupMutuallyExclusiveCheckboxes() {
              const dryRunCheckbox = document.getElementById('id_dry_run');
              const deployCheckbox = document.getElementById('id_deploy_changes');

              if (dryRunCheckbox && deployCheckbox) {
                // Handler for dry run checkbox changes
                const handleDryRunChange = function() {
                  if (this.checked) {
                    deployCheckbox.checked = false;
                    deployCheckbox.disabled = true;
                    deployCheckbox.parentElement.style.opacity = '0.5';
                  } else {
                    deployCheckbox.disabled = false;
                    deployCheckbox.parentElement.style.opacity = '1';
                  }
                  updateDeployButtonState();
                };
                
                // Handler for deploy changes checkbox changes
                const handleDeployChange = function() {
                  if (this.checked) {
                    dryRunCheckbox.checked = false;
                    dryRunCheckbox.disabled = true;
                    dryRunCheckbox.parentElement.style.opacity = '0.5';
                  } else {
                    dryRunCheckbox.disabled = false;
                    dryRunCheckbox.parentElement.style.opacity = '1';
                  }
                  updateDeployButtonState();
                };
                
                dryRunCheckbox.addEventListener('change', handleDryRunChange);
                deployCheckbox.addEventListener('change', handleDeployChange);

                // Initialize state on page load
                if (dryRunCheckbox.checked) {
                  deployCheckbox.disabled = true;
                  deployCheckbox.parentElement.style.opacity = '0.5';
                } else if (deployCheckbox.checked) {
                  dryRunCheckbox.disabled = true;
                  dryRunCheckbox.parentElement.style.opacity = '0.5';
                }
                
                // Update button state on page load
                updateDeployButtonState();
              }
            }

            // Initialize function - follows proven pattern from vlan_tagging_form.html
            function initVlanDeploymentForm() {
              console.log('=== initVlanDeploymentForm called ===');
              console.log('Document ready state:', document.readyState);
              
              // Set initial state first (critical - this must run on page load)
              console.log('Step 1: Calling updateFieldVisibility...');
              // Force immediate execution
              try {
                updateFieldVisibility();
              } catch (e) {
                console.error('Error in updateFieldVisibility:', e);
              }
              // Also call with delays to ensure it works
              setTimeout(() => {
                try {
                  updateFieldVisibility();
                } catch (e) {
                  console.error('Error in updateFieldVisibility (50ms):', e);
                }
              }, 50);
              setTimeout(() => {
                try {
                  updateFieldVisibility();
                } catch (e) {
                  console.error('Error in updateFieldVisibility (200ms):', e);
                }
              }, 200);
              setTimeout(() => {
                try {
                  updateFieldVisibility();
                } catch (e) {
                  console.error('Error in updateFieldVisibility (500ms):', e);
                }
              }, 500);
              setTimeout(() => {
                try {
                  updateFieldVisibility();
                } catch (e) {
                  console.error('Error in updateFieldVisibility (1000ms):', e);
                }
              }, 1000);
              setTimeout(() => {
                try {
                  updateFieldVisibility();
                } catch (e) {
                  console.error('Error in updateFieldVisibility (2000ms):', e);
                }
              }, 2000);

              // Also set up periodic check every 2 seconds for the first 10 seconds
              let periodicCheckCount = 0;
              const periodicCheck = setInterval(() => {
                periodicCheckCount++;
                try {
                  updateFieldVisibility();
                  console.log('Periodic field visibility check #' + periodicCheckCount);
                } catch (e) {
                  console.error('Error in periodic updateFieldVisibility:', e);
                }
                if (periodicCheckCount >= 5) {
                  clearInterval(periodicCheck);
                  console.log('Stopped periodic field visibility checks');
                }
              }, 2000);

              console.log('Step 2: Calling updateSyncModeState...');
              updateSyncModeState();
              
              // Step 2.5: If devices are pre-selected, load interfaces and VLANs
              const devicesSelect = document.getElementById('id_devices');
              if (devicesSelect) {
                let hasSelectedDevices = false;
                let selectedDeviceIds = [];
                
                // Check native select
                if (devicesSelect.selectedOptions && devicesSelect.selectedOptions.length > 0) {
                  selectedDeviceIds = Array.from(devicesSelect.selectedOptions).map(opt => opt.value);
                  hasSelectedDevices = true;
                }
                // Check TomSelect
                if (!hasSelectedDevices && devicesSelect.tomselect) {
                  const tomSelectValue = devicesSelect.tomselect.getValue();
                  if (tomSelectValue && (Array.isArray(tomSelectValue) ? tomSelectValue.length > 0 : tomSelectValue)) {
                    selectedDeviceIds = Array.isArray(tomSelectValue) ? tomSelectValue : [tomSelectValue];
                    hasSelectedDevices = true;
                  }
                }
                // Check Select2
                if (!hasSelectedDevices && typeof jQuery !== 'undefined' && jQuery(devicesSelect).data('select2')) {
                  const select2Value = jQuery(devicesSelect).val();
                  if (select2Value && (Array.isArray(select2Value) ? select2Value.length > 0 : select2Value)) {
                    selectedDeviceIds = Array.isArray(select2Value) ? select2Value : [select2Value];
                    hasSelectedDevices = true;
                  }
                }
                
                if (hasSelectedDevices && selectedDeviceIds.length > 0) {
                  console.log('Step 2.5: Devices pre-selected, loading interfaces and VLANs...');
                  const syncCheckbox = document.getElementById('id_sync_netbox_to_device');
                  if (syncCheckbox && syncCheckbox.checked) {
                    setTimeout(() => loadInterfacesForSync(), 100);
                  } else {
                    setTimeout(() => {
                      loadCommonInterfaces();
                      // VLANs will be loaded by loadCommonInterfaces callback
                    }, 100);
                  }
                }
              }
              
              console.log('Step 3: Calling setupMutuallyExclusiveCheckboxes...');
              setupMutuallyExclusiveCheckboxes();
              
              console.log('Step 4: Calling updateDeployButtonState...');
              updateDeployButtonState();

              // Listen for scope changes
              document.querySelectorAll('input[name="deployment_scope"]').forEach(radio => {
                radio.addEventListener('change', function() {
                  console.log('Deployment scope changed to:', this.value);
                  updateFieldVisibility();
                  // Also run multiple times to ensure it takes effect
                  setTimeout(updateFieldVisibility, 50);
                  setTimeout(updateFieldVisibility, 200);
                });
              });
              
              // Also add MutationObserver to catch any dynamic changes
              const observer = new MutationObserver(function(mutations) {
                const scopeRadio = document.querySelector('input[name="deployment_scope"]:checked');
                if (scopeRadio) {
                  updateFieldVisibility();
                }
              });
              const scopeContainer = document.querySelector('input[name="deployment_scope"]')?.closest('.mb-3');
              if (scopeContainer) {
                observer.observe(scopeContainer, { attributes: true, childList: true, subtree: true });
              }

              // Listen for sync mode checkbox changes
              const syncCheckbox = document.getElementById('id_sync_netbox_to_device');
              if (syncCheckbox) {
                syncCheckbox.addEventListener('change', function() {
                  updateSyncModeState();
                  // Also run immediate check after a short delay to ensure it takes effect
                  setTimeout(runImmediateSyncCheck, 50);
                });
                // Also check immediately in case checkbox is already checked
                if (syncCheckbox.checked) {
                  setTimeout(function() {
                    updateSyncModeState();
                    runImmediateSyncCheck();
                  }, 100);
                }
              }

              // Listen for device selection changes (single mode)
              // devicesSelect already declared above, reuse it
              if (devicesSelect) {
                function loadInterfacesBasedOnSyncMode() {
                  console.log('loadInterfacesBasedOnSyncMode called');
                  const syncCheckbox = document.getElementById('id_sync_netbox_to_device');
                  if (syncCheckbox && syncCheckbox.checked) {
                    console.log('Sync mode active, loading interfaces for sync');
                    loadInterfacesForSync();
                  } else {
                    console.log('Normal mode, loading common interfaces');
                    loadCommonInterfaces();
                  }
                }

                // Add native change event listener
                devicesSelect.addEventListener('change', function() {
                  console.log('Device selection changed (native event)');
                  loadInterfacesBasedOnSyncMode();
                });
                
                // Listen for TomSelect events (NetBox's default)
                if (devicesSelect.tomselect) {
                  console.log('TomSelect found, adding change listener');
                  devicesSelect.tomselect.on('change', function() {
                    console.log('Device selection changed (TomSelect event)');
                    loadInterfacesBasedOnSyncMode();
                  });
                } else {
                  // Wait for TomSelect to initialize
                  console.log('Waiting for TomSelect to initialize...');
                  const checkTomSelect = setInterval(function() {
                    if (devicesSelect.tomselect) {
                      console.log('TomSelect initialized, adding change listener');
                      devicesSelect.tomselect.on('change', function() {
                        console.log('Device selection changed (TomSelect event - delayed)');
                        loadInterfacesBasedOnSyncMode();
                      });
                      clearInterval(checkTomSelect);
                      const currentValue = devicesSelect.tomselect.getValue();
                      if (currentValue && (Array.isArray(currentValue) ? currentValue.length > 0 : currentValue)) {
                        console.log('Devices already selected, loading interfaces...');
                        loadInterfacesBasedOnSyncMode();
                      }
                    }
                  }, 100);
                  setTimeout(function() { clearInterval(checkTomSelect); }, 5000);
                }
                
                // Listen for Select2 events (if Select2 is initialized and jQuery is available)
                if (typeof jQuery !== 'undefined' && jQuery(devicesSelect).data('select2')) {
                  jQuery(devicesSelect).on('select2:select select2:unselect select2:clear', loadInterfacesBasedOnSyncMode);
                } else if (typeof jQuery !== 'undefined') {
                  // Wait for Select2 to initialize
                  const checkSelect2 = setInterval(function() {
                    if (typeof jQuery !== 'undefined' && jQuery(devicesSelect).data('select2')) {
                      jQuery(devicesSelect).on('select2:select select2:unselect select2:clear', loadInterfacesBasedOnSyncMode);
                      clearInterval(checkSelect2);
                      if (typeof jQuery !== 'undefined' && jQuery(devicesSelect).val() && jQuery(devicesSelect).val().length > 0) {
                        loadInterfacesBasedOnSyncMode();
                      }
                    }
                  }, 100);
                  setTimeout(function() { clearInterval(checkSelect2); }, 5000);
                }

                // Check if devices are already selected (native select, TomSelect, or Select2)
                let hasSelectedDevices = false;
                let selectedDeviceIds = [];
                
                if (devicesSelect.selectedOptions && devicesSelect.selectedOptions.length > 0) {
                  selectedDeviceIds = Array.from(devicesSelect.selectedOptions).map(opt => opt.value);
                  hasSelectedDevices = true;
                } else if (devicesSelect.tomselect) {
                  const tomSelectValue = devicesSelect.tomselect.getValue();
                  if (tomSelectValue && (Array.isArray(tomSelectValue) ? tomSelectValue.length > 0 : tomSelectValue)) {
                    selectedDeviceIds = Array.isArray(tomSelectValue) ? tomSelectValue : [tomSelectValue];
                    hasSelectedDevices = true;
                  }
                } else if (typeof jQuery !== 'undefined' && jQuery(devicesSelect).data('select2')) {
                  const select2Value = jQuery(devicesSelect).val();
                  if (select2Value && (Array.isArray(select2Value) ? select2Value.length > 0 : select2Value)) {
                    selectedDeviceIds = Array.isArray(select2Value) ? select2Value : [select2Value];
                    hasSelectedDevices = true;
                  }
                }
                
                if (hasSelectedDevices) {
                  setTimeout(() => {
                    loadInterfacesBasedOnSyncMode();
                    // Also load VLANs if not in sync mode
                    const syncCheckbox = document.getElementById('id_sync_netbox_to_device');
                    if (!syncCheckbox || !syncCheckbox.checked) {
                      if (selectedDeviceIds.length > 0) {
                        filterVLANsByDevices(selectedDeviceIds);
                      }
                    }
                  }, 200);
                }
              }

              // Listen for group filter changes (group mode)
              const siteSelect = document.getElementById('id_site');
              const locationSelect = document.getElementById('id_location');
              const manufacturerSelect = document.getElementById('id_manufacturer');
              const roleSelect = document.getElementById('id_role');
              
              if (siteSelect) {
                siteSelect.addEventListener('change', function() {
                  filterVLANsBySite();
                  loadInterfacesFromGroupFilters();
                });
              }
              
              if (locationSelect) {
                locationSelect.addEventListener('change', loadInterfacesFromGroupFilters);
              }
              
              if (manufacturerSelect) {
                manufacturerSelect.addEventListener('change', loadInterfacesFromGroupFilters);
              }
              
              if (roleSelect) {
                roleSelect.addEventListener('change', loadInterfacesFromGroupFilters);
              }
              
              // Listen for excluded devices changes to reload interfaces
              const excludedDevicesSelect = document.getElementById('id_excluded_devices');
              if (excludedDevicesSelect) {
                excludedDevicesSelect.addEventListener('change', function() {
                  console.log('Event: Excluded devices changed, reloading interfaces...');
                  loadInterfacesFromGroupFilters();
                });
                // Also listen for Select2 events if Select2 is used
                if (typeof jQuery !== 'undefined' && jQuery(excludedDevicesSelect).data('select2')) {
                  jQuery(excludedDevicesSelect).on('select2:select select2:unselect select2:clear', function() {
                    console.log('Event: Excluded devices changed (Select2), reloading interfaces...');
                    loadInterfacesFromGroupFilters();
                  });
                } else if (typeof jQuery !== 'undefined') {
                  // Wait for Select2 to initialize
                  const checkSelect2 = setInterval(function() {
                    if (typeof jQuery !== 'undefined' && jQuery(excludedDevicesSelect).data('select2')) {
                      jQuery(excludedDevicesSelect).on('select2:select select2:unselect select2:clear', function() {
                        console.log('Event: Excluded devices changed (Select2), reloading interfaces...');
                        loadInterfacesFromGroupFilters();
                      });
                      clearInterval(checkSelect2);
                    }
                  }, 100);
                  setTimeout(function() { clearInterval(checkSelect2); }, 5000);
                }
              }
            }
            
            // MINIMAL FIX: Only device names in accordion buttons in dark mode
            // UPDATED: Preserve vibrant device name colors - only apply default colors to other elements
            function forceWhiteText() {
              const isDark = document.documentElement.getAttribute('data-theme') === 'dark' || 
                            document.body.classList.contains('dark-mode') ||
                            document.documentElement.getAttribute('data-bs-theme') === 'dark';
              
              // Only apply default colors to non-device-name elements
              // Device names should keep their vibrant colors set in renderInterfacesAccordion
              document.querySelectorAll('.accordion-button strong, .accordion-button .device-name, .accordion-header button strong').forEach(el => {
                // SKIP device-name elements - they should keep their vibrant colors
                if (el.classList.contains('device-name')) {
                  return; // Skip - preserve vibrant color
                }
                
                // Only apply default colors to other elements (not device names)
                if (!el.closest('.badge') && !el.closest('.btn') && !el.classList.contains('device-name')) {
                  if (isDark) {
                    el.style.setProperty('color', 'var(--nbx-color-fg-default, #ffffff)', 'important');
                  }
                  // Force on direct children (but skip device-name)
                  el.querySelectorAll('*').forEach(child => {
                    if (!child.closest('.badge') && !child.closest('.btn') && !child.classList.contains('device-name')) {
                      if (isDark) {
                        child.style.setProperty('color', 'var(--nbx-color-fg-default, #ffffff)', 'important');
                      }
                    }
                  });
                }
              });
            }
            
            // Initialize on page load - using proven pattern from vlan_tagging_form.html
            // Also run updateSyncModeState immediately to hide/show fields based on checkbox state
            function runImmediateSyncCheck() {
              try {
                const syncCheckbox = document.getElementById('id_sync_netbox_to_device');
                const vlanConfigContainer = document.getElementById('vlan-config-container');
                const untaggedVlanField = document.getElementById('id_untagged_vlan');
                const taggedVlansField = document.getElementById('id_tagged_vlans');
                
                console.log('runImmediateSyncCheck - checkbox found:', !!syncCheckbox, 'checked:', syncCheckbox ? syncCheckbox.checked : false);
                console.log('runImmediateSyncCheck - container found:', !!vlanConfigContainer);
                
                if (syncCheckbox && syncCheckbox.checked) {
                  console.log('Immediate sync check: Hiding VLAN fields');
                  
                  // Hide main container with multiple methods
                  if (vlanConfigContainer) {
                    vlanConfigContainer.style.display = 'none';
                    vlanConfigContainer.style.visibility = 'hidden';
                    vlanConfigContainer.style.height = '0';
                    vlanConfigContainer.style.overflow = 'hidden';
                    vlanConfigContainer.style.margin = '0';
                    vlanConfigContainer.style.padding = '0';
                    vlanConfigContainer.setAttribute('style', 'display: none !important; visibility: hidden !important; height: 0 !important; overflow: hidden !important; margin: 0 !important; padding: 0 !important;');
                    vlanConfigContainer.classList.add('hidden-by-sync');
                    console.log('Container hidden, style:', vlanConfigContainer.getAttribute('style'));
                  }
                  
                  // Hide individual field containers as backup
                  if (untaggedVlanField) {
                    untaggedVlanField.disabled = true;
                    const untaggedContainer = untaggedVlanField.closest('.mb-3');
                    if (untaggedContainer) {
                      untaggedContainer.style.display = 'none';
                      untaggedContainer.setAttribute('style', 'display: none !important;');
                      console.log('Untagged container hidden');
                    }
                  }
                  
                  if (taggedVlansField) {
                    taggedVlansField.disabled = true;
                    const taggedContainer = taggedVlansField.closest('.mb-3');
                    if (taggedContainer) {
                      taggedContainer.style.display = 'none';
                      taggedContainer.setAttribute('style', 'display: none !important;');
                      console.log('Tagged container hidden');
                    }
                  }
                } else if (syncCheckbox && !syncCheckbox.checked) {
                  // Show fields if not in sync mode
                  if (vlanConfigContainer) {
                    vlanConfigContainer.style.display = 'block';
                    vlanConfigContainer.style.visibility = 'visible';
                    vlanConfigContainer.style.height = 'auto';
                    vlanConfigContainer.style.overflow = 'visible';
                    vlanConfigContainer.removeAttribute('style');
                    vlanConfigContainer.classList.remove('hidden-by-sync');
                  }
                }
              } catch (e) {
                console.error('Immediate sync check failed:', e);
              }
            }
            
            // Run immediate field visibility check
            function runImmediateFieldVisibility() {
              try {
                const scopeRadio = document.querySelector('input[name="deployment_scope"]:checked');
                const singleFields = document.getElementById('single-device-fields');
                const groupFields = document.getElementById('group-device-fields');
                
                console.log('runImmediateFieldVisibility - scopeRadio:', scopeRadio ? scopeRadio.value : 'not found');
                console.log('runImmediateFieldVisibility - singleFields:', !!singleFields, 'groupFields:', !!groupFields);
                
                if (singleFields && groupFields) {
                  if (scopeRadio && scopeRadio.value === 'group') {
                    console.log('Setting group mode - hiding single, showing group');
                    singleFields.style.display = 'none';
                    singleFields.style.visibility = 'hidden';
                    singleFields.setAttribute('style', 'display: none !important; visibility: hidden !important;');
                    groupFields.style.display = 'block';
                    groupFields.style.visibility = 'visible';
                    groupFields.setAttribute('style', 'display: block !important; visibility: visible !important;');
                    console.log('Group fields should now be visible');
                  } else {
                    console.log('Setting single mode - showing single, hiding group');
                    singleFields.style.display = 'block';
                    singleFields.style.visibility = 'visible';
                    singleFields.setAttribute('style', 'display: block !important; visibility: visible !important;');
                    groupFields.style.display = 'none';
                    groupFields.style.visibility = 'hidden';
                    groupFields.setAttribute('style', 'display: none !important; visibility: hidden !important;');
                    console.log('Single fields should now be visible');
                  }
                }
              } catch (e) {
                console.error('Immediate field visibility check failed:', e);
              }
            }
            
            // Run sync check multiple times to ensure it catches the checkbox state
            function runSyncCheckMultipleTimes() {
              runImmediateSyncCheck();
              setTimeout(runImmediateSyncCheck, 50);
              setTimeout(runImmediateSyncCheck, 100);
              setTimeout(runImmediateSyncCheck, 200);
              setTimeout(runImmediateSyncCheck, 500);
            }
            
            // Run immediately if DOM is ready
            if (document.readyState !== 'loading') {
              runImmediateFieldVisibility();
              setTimeout(runImmediateFieldVisibility, 50);
              setTimeout(runImmediateFieldVisibility, 200);
              runSyncCheckMultipleTimes();
            }
            
            if (document.readyState === 'loading') {
              document.addEventListener('DOMContentLoaded', function() {
                runImmediateFieldVisibility();
                setTimeout(runImmediateFieldVisibility, 50);
                setTimeout(runImmediateFieldVisibility, 200);
                runSyncCheckMultipleTimes();
                initVlanDeploymentForm();
                // Force white text on device names - AGGRESSIVE timing
                forceWhiteText();
                setTimeout(forceWhiteText, 50);
                setTimeout(forceWhiteText, 100);
                setTimeout(forceWhiteText, 300);
                setTimeout(forceWhiteText, 500);
                setTimeout(forceWhiteText, 1000);
                setTimeout(forceWhiteText, 2000);
                
                // More aggressive periodic check - every 1 second
                setInterval(forceWhiteText, 1000);
                
                // MutationObserver to catch any dynamically added elements
                const observer = new MutationObserver(function(mutations) {
                  forceWhiteText();
                });
                observer.observe(document.body, {
                  childList: true,
                  subtree: true,
                  attributes: true,
                  attributeFilter: ['style', 'class', 'data-theme', 'data-bs-theme']
                });
                
                // Listen for theme changes
                window.addEventListener('netbox.colorModeChanged', function() {
                  setTimeout(forceWhiteText, 50);
                  setTimeout(forceWhiteText, 100);
                  setTimeout(forceWhiteText, 300);
                });
              });
            } else {
              // DOM is already ready
              runImmediateFieldVisibility();
              setTimeout(runImmediateFieldVisibility, 50);
              setTimeout(runImmediateFieldVisibility, 200);
              runSyncCheckMultipleTimes();
              initVlanDeploymentForm();
              forceWhiteText();
              setTimeout(forceWhiteText, 50);
              setTimeout(forceWhiteText, 100);
              setTimeout(forceWhiteText, 300);
              setTimeout(forceWhiteText, 500);
              setTimeout(forceWhiteText, 1000);
              setInterval(forceWhiteText, 1000);
              
              // MutationObserver
              const observer = new MutationObserver(function(mutations) {
                forceWhiteText();
              });
              observer.observe(document.body, {
                childList: true,
                subtree: true,
                attributes: true,
                attributeFilter: ['style', 'class', 'data-theme', 'data-bs-theme']
              });
            }

            // Form submission handler
            document.getElementById('vlan-deployment-form').addEventListener('submit', function(e) {
              // Show loading overlay
              const overlay = document.getElementById('loading-overlay');
              overlay.style.display = 'flex';

              // Disable form button
              document.getElementById('deploy-btn').disabled = true;
            });
          </script>
        </div>
      </div>
    </div>
  </div>
{% endblock %}

